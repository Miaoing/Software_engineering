# 面向过程的总体设计

## 面向过程的总体设计

### 结构化的总体设计方法

* 首先研究, 分析 和审查 数据流图.  从软件的需求规格说明中弄清数据加工的过程, 对于发现的问题及时解决.
* 然后根据数据流图决定问题的类型.  数据处理问题典型的类型有两种:  变换型和事物型. 针对两种不同的类型分别进行分析处理.
* 由数据流图导出系统的初始化结构图.  **这个系统结构图是最重要的部分**
* 利用一些启发式原则来改进系统的初始化结构图, 知道得到符合要求的结构图为止
* 修改和补充数据词典.

### 在系统结构图中的模块

* **传入模块**
  * 它从**`下属模块`**取得数据,  经过某些数据, 再将其传送给**`上级模块`**.  **他传送的数据流叫做`逻辑输入数据流`.**
* **传出模块**
  * 它从**`上级模块`**取得数据, 进行某些处理, 再将其传送给**`下属模块`**.  **他传送的数据流叫做`逻辑输出数据流`.**
* **变换模块**
  * 它从**`上级模块`**取得数据, 进行特定的处理, 转换成其他形式, 在传送回**`上级模块`**. 它加工的数据流叫做**`变换数据流.   (数据从哪里来,就返回哪里去)`**
* **协调模块**
  * 对所有**`下属模块`**进行协调和管理的模块.

![&#x4F20;&#x5165;&#x6A21;&#x5757;, &#x4F20;&#x51FA;&#x6A21;&#x5757;, &#x53D8;&#x6362;&#x6A21;&#x5757;, &#x534F;&#x8C03;&#x6A21;&#x5757;](../.gitbook/assets/image%20%28127%29.png)

### 变换型系统结构图

* 变换型数据处理问题的工作大致分为**三步**,即  **`取得数据, 交换数据 和 给出数据`**.
* 相应于 **`取得数据, 变换数据, 给出数据`** , **变换型系统构造图由`输入, 中心变换 和 输出`**等三部分组成.

![&#x53D8;&#x6362;&#x6027;&#x4F53;&#x7CFB;&#x7ED3;&#x6784;&#x56FE;](../.gitbook/assets/image%20%28110%29.png)

### 事务性系统结构图

* 它接受一项书屋, 根据事务处理的特点和性质, 选择分派一个适当的处理单元, 然后给出结果.
* 在事物型系统结构图中, **`事务中心模块`** 按所接受的事物的类型,  选择某一事务处理模块执行. 各事**`务处理模块`** 并列. 每个事务处理模块可能要调用若干个**`操作模块`**, 而操作模块又可能调用若干个**`细节模块.`**

![&#x4E8B;&#x52A1;&#x6027;&#x7CFB;&#x7EDF;&#x7ED3;&#x6784;&#x56FE;](../.gitbook/assets/image%20%28181%29.png)

### 变换型 与 事务性 分析

#### 变换性分析

* 是从数据流图推倒出变换型 体系结构 的过程
  * **第一步是** **`重画数据流图`**
  * **第二步是** **`区分有效(逻辑) 输入, 有效(逻辑) 输出 和中心变换部分`**
  * **第三步是 进行一级分解, 设计上层模块**
  * **第四步是 `进行二级分解, 设计输入, 输出 和 中心变换部分的中, 下层模块.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41;&#x56FE;, &#x4E0B;&#x9762;&#x662F;&#x6839;&#x636E;&#x6570;&#x636E;&#x6D41;&#x56FE;&#x91CD;&#x753B;&#x7684;&#x53D8;&#x6362;&#x578B;&#x6570;&#x636E;&#x6D41;&#x56FE;](../.gitbook/assets/image%20%28211%29.png)

#### 变换分析注意事项

* **深度遍历模块设计**
  * 在选择模块设计的次序时,必须对一个模块的全部直接下属模块都设计完成之后, 才能转向另一个模块的下层模块的设计.
* **耦合与内聚**
  * 在设计下层模块时, 应考虑模块的耦合和内聚问题, 以提高初始结构图的质量.
* **使用 "黑箱"  技术**
  * 在设计当前模块时, 先把这个模块的所有下层模块定义成 "黑箱", 在设计中利用它们时, 暂时不考虑其内部结构和实现. 在这一步定义好的 "黑箱" , 在下一步就可以对他们进行设计和加工. 这样, 又导致更多的 "黑箱". 最后, 全部 "黑箱" 的内容结构应完全被确定.
* **控制直接下属的模块数**
  * 在模块划分时, 一个模块的直接下属模块一般在5个左右. 如果下属模块超过10个, 可设立中间层次.
* **停止模块功能分解的情况**
  * 模块不能再分析称为明显的子任务.
  * 分解成用户提供的模块或程序库的子程序;
  * 模块的界面是输出 /  输出设备传送的信息;
  * 模块不易再分解得过小.



#### 事务性分析

* 在很多软件应用中, 存在某种软件数据流, 他可以引发一个或多个处理, 这些处理能够完成该作业要求的功能. 这种**数据流**就叫做**`事务`.  \(可以把一个界面的主控台 看成是事务的中心\)**
* 和变换分析一样, 事务分析也是从分析数据流图开始**`, 自顶向下, 逐步分解, 建立系统结构图.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41; , &#x4E0B;&#x9762;&#x662F;&#x4E8B;&#x52A1;&#x5206;&#x6790;&#x540E;&#x7684;&#x6570;&#x636E;&#x6D41;,  4 5  6 &#x7684;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4F1A;&#x8FD4;&#x56DE;&#x7ED9;&#x4E3B;&#x63A7;, &#x7136;&#x540E;&#x518D;&#x7531;&#x4E3B;&#x63A7;&#x8F93;&#x51FA;](../.gitbook/assets/image%20%28214%29.png)

#### 事务型分析过程

该过程自顶向下 依次执行

* **识别事务源**
  * 利用数据流图和数据字典, 从问题定义和需求分析的结果中, 找出各种需要处理的事务, 通常, 事务来自物理输入装置. 有时, 设计人员还必须区别 **`系统的输入, 中心加工 和 输出`**中产生的事务.
* **规定适当的事务性结构**
  * 在确定了该数据流图具有事务性特征之后, 根据模块划分理论, 建立适当的事务性结构.
* **识别各种事务和他们定义的操作**
  * 从问题定义和需求分析中找出的**`事务及其操作必须的全部信息,`** 对于系统内部产生的事务, **必须仔细的定义他们的操作.**
* **注意利用公共模块**
  * 在事务分析的过程中, 如果不同事务的一些中间模块可由具有类似的语法和语义的若干个底层模块组成, 则可以把这些底层模块构造成`公共模块.`
* **事务处理模块**
  * 对每一事务, 或对联系密切的一组事务, **`建立一个事务处理模块`**; 如果发现在系统中有类似的事务, 可以把他们**`组成一个事务处理模块`**.
* **操作模块**
  * 对事务处理模块规定 他们全部的下层**`操作模块.`**
* **细节模块**
  * 对操作模块规定 他们的全部**`细节模块`**.

![&#x4E8B;&#x52A1;&#x578B;&#x5206;&#x6790;&#x8FC7;&#x7A0B;](../.gitbook/assets/image%20%28132%29.png)

### 混合结构分析

* **变换分析是软件系统结构设计的主要方法.**
  * 一般一个大型的软件系统是**`变换型结构`**和**`事务性结构`**和**`混合结构.`**
* **所以, 我们通常利用以 `变换分析为主, 事务分析为辅` 的方式进行软件结构设计.**

![&#x6DF7;&#x5408;&#x6A21;&#x578B;&#x7684;&#x6848;&#x4F8B;, &#x4E8B;&#x52A1;&#x6027;&#x548C;&#x53D8;&#x6362;&#x578B;](../.gitbook/assets/image%20%2850%29.png)

### 面向过程的组件设计之 流程图

#### 结构化的组件设计

* 组件设计也称为**`过程设计,详细设计, 位于数据设计`**,  **是位于`体系结构设计 和接口设计`**完成之**`后`**进行设计的.
* **对于结构化组件设计来说, 任何程序总可以用三种结构化的构成元素来设计和实现.**
  * **顺序 :** 任何算法规约中的核心处理步骤.  也就是从前往后的处理步骤.
  * **条件:** 允许根据逻辑情况选择处理的方式, 也就是判断
  * **重复:** 提供了循环
* **详细设计的工具可以分为以下三类**
  * **图形设计符号:**    **`流程图, 盒图, 等`**
  * **表格设计符号:**    **`决策表 ,等`**
  * **程序设计语言**:    **`PDL 等`**



#### 流程图

利用各种**`方块图形, 线条, 及箭头`**等符号来表达解决问题的步骤及进行的**`顺序`**;  **`是算法的一种表示方式`**

* **常见的两种流程图**
  * **标准作业流程 \(SOP , Standard  operating procedure\)**
    * 企业界常用的一种作业方法, 其目的在使每一项作业流程均能清楚呈现, 任何人只要看到了流程图, 便能一目了然, 有助于相关作业人员对整体工作流程的掌握.
  * **程序流程图 \(program flow chart\)**
    * 表示程序中的处理过程.

#### 流程图的优点

* 所有流程一目了然, 工作人员能掌握全局.
* 更换人手时, 按图索意, 容易上手.
* 所有流程在绘制时, 很容易发现疏失之处, 可适时予以调整更正, 使各项作业更为严谨.

#### 流程图的基本符号

![&#x6D41;&#x7A0B;&#x56FE;&#x7684;&#x57FA;&#x672C;&#x7B26;&#x53F7; 1 ](../.gitbook/assets/image%20%2835%29.png)

![&#x6D41;&#x7A0B;&#x56FE;&#x7684;&#x57FA;&#x672C;&#x7B26;&#x53F7; 2](../.gitbook/assets/image%20%28220%29.png)

#### 流程图的基本结构

* **顺序结构 \(Sequence\)**
  * 处理程序顺序进行, 用控制流来连接处理的程序
* **选择结构\(selection\)**
  * **二元结构** \(基本结构\)
    * 流程依据某些条件, 依条件是否成立, 分别进行不同处理程序.
  * **多重选择结构**
    * 可以根据一个条件的取值, 选择不同的分支进行处理,   与二元结构的区别 就是处理数目不同.
* **循环结构\(Iteration\)**
  * while - do 结构
  * do - while 结构

#### 流程图结构 - 顺序结构

![&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x987A;&#x5E8F;&#x8FDB;&#x884C;,&#x7528;&#x63A7;&#x5236;&#x6D41;&#x6765;&#x8FDE;&#x63A5;](../.gitbook/assets/image%20%28201%29.png)

#### 流程图结构 -选择结构  - 二元选择结构

![&#x6D41;&#x7A0B;&#x4F9D;&#x636E;&#x67D0;&#x4E9B;&#x6761;&#x4EF6;, &#x4F9D;&#x6761;&#x4EF6;&#x662F;&#x5426;&#x6210;&#x7ACB;, &#x5206;&#x522B;&#x8FDB;&#x884C;&#x4E0D;&#x540C;&#x5904;&#x7406;&#x7A0B;&#x5E8F;](../.gitbook/assets/image%20%2872%29.png)

#### 流程图结构 -选择结构  - 多重选择结构

![&#x6BD4;&#x4E8C;&#x5143;&#x7ED3;&#x6784; &#x591A;&#x4E86;&#x5F88;&#x591A;&#x5224;&#x65AD;&#x6761;&#x4EF6;](../.gitbook/assets/image%20%28149%29.png)

#### 流程图结构 - 循环结构 - while do 结构

![while do &#x7ED3;&#x6784;](../.gitbook/assets/image%20%28143%29.png)

#### 流程图结构 - 循环结构 - do while  结构

![do while &#x7ED3;&#x6784;](../.gitbook/assets/image%20%2880%29.png)

#### 流程图绘制原则

1. 各项步骤有选择或决策结构, 入 "可/否" ,  "通过/不通过" , 或其他相对文字时, 请检查校正流程是否有遗漏, 以避免悬而未决的状况.
2. 流程图符号绘制排列顺序, 为由上而下, 由左而右.
3. 处理程序可用阿拉伯数字, 从1开始, 依处理程序排列顺序编号, 并以文字处理程序功能命名. ![](../.gitbook/assets/image%20%28138%29.png) 
4. 相同流程图符号 应该一大小一致.
5. 路径符号应该避免相互交叉.  

   ![](../.gitbook/assets/image%20%28188%29.png)

6. 同一路径符号的指示箭头应只有一个  

   ![](../.gitbook/assets/image%20%28221%29.png)

7. 开始符号在流程图中只能出现一次, 但结束符号则不限. 若流程图能一目了然, 则开始符号和结束符号可以省略.
8. 选择结构与重复结构的选择与决策条件, 文件叙述应简明清晰, 路径加注 "是", "否" 或其他相对性文字指示说明.
9. 流程图中若有参考到其他已定义流程, 可使用定义处理程序符号, 不必重复绘制.  

   ![](../.gitbook/assets/image%20%28131%29.png)

10. 流程图若一页绘制不下, 可以使用分级分页绘制方式, 并在处理程序编号上表示其级别.  

    ![](../.gitbook/assets/image%20%2863%29.png)\*\*\*\*

**示例 : 输出 0~9 的数**

![do while &#x7684;&#x5FAA;&#x73AF;&#x7ED3;&#x6784;](../.gitbook/assets/image%20%28213%29.png)

**示例 : 输入5个实数, 计算平均值, 然后再打印该平均值**

![&#x5FAA;&#x73AF;&#x8F93;&#x5165;&#x548C;&#x6587;&#x4EF6;&#x6253;&#x5370;](../.gitbook/assets/image%20%28147%29.png)

**示例:收邮件**

![&#x5F88;&#x590D;&#x6742;](../.gitbook/assets/image%20%28216%29.png)

### 面向过程的其他组件设计方法

#### 盒图 \(N-S图\)

![&#x548C;&#x6D41;&#x7A0B;&#x56FE;&#x5F88;&#x50CF;,  UNTIL &#x662F; do while &#x578B;](../.gitbook/assets/image%20%28228%29.png)

**盒图示例**

![&#x793A;&#x4F8B;](../.gitbook/assets/image%20%284%29.png)

#### **PDL \(程序设计语言\)**

* PDL 是一种用于描述功能模块的算法设计和加工系统的语言. 简称**程序设计语言**. **它是一种`伪码`.**
* 伪码的语法规则范围 "**`外语法`**" 和 "**`内语法`"**
* PDL具有**`严格关键字外语法`**, 用于定义控制结构和数据结构, 同时它的表示实际操作和条件的内语法又是灵活自由的. 可使用自然语言的词汇.

**PDL示例:  拼词检查程序**

![&#x53F3;&#x4FA7;&#x7684;&#x7EA2;&#x8272;&#x90E8;&#x5206;&#x662F;&#x6CE8;&#x89C6; ,&#x800C;&#x4E14;&#x6807;&#x6CE8;&#x7684;&#x662F;&#x5DE6;&#x8FB9;&#x7684;&#x6E90;&#x7801;](../.gitbook/assets/image%20%28227%29.png)

#### 判定表 \(决策表\)

* **`判定用于表示程序静态逻辑.`**
* 在判定表中的**`条件部分`**给出所有的两分支判断的列表, **`动作部分`**给出相应的处理.
* 要求将程序流图中的多分支判断都改成**`两分支`**判断.

主要用在软件测试里. 用来判断 输出,输入,动作 是否都符合预期.

![&#x6761;&#x4EF6;&#x90E8;&#x5206;&#x548C;&#x52A8;&#x4F5C;&#x90E8;&#x5206;](../.gitbook/assets/image%20%28136%29.png)

#### 无多分支流程图 -&gt; 判定图

![- &#x4EE3;&#x8868;, Y &#x548C;&#x975E;Y &#x7ED3;&#x679C;&#x5982;&#x4F55; &#x4ED6;&#x90FD;&#x4F1A;&#x6267;&#x884C;, &#x6BD4;&#x5982; &#x7B2C;&#x4E00;&#x6570;&#x5217;&#x7684; c,d,e,g,h](../.gitbook/assets/image%20%289%29.png)



