# 系统设计

## 软件设计的概念与设计质量

### 软件设计的定义

在 IEEE610.12-90 中 ,软件设计定义为软件 **`系统或组建的架构, 构件, 接口和其他特征`**的定义过程及该过程的结果.

![&#x8BBE;&#x8BA1;&#x5728;&#x5206;&#x6790;&#x4E4B;&#x540E;&#x8FDB;&#x884C;.](.gitbook/assets/image%20%28220%29.png)

### 软件设计

![&#x8F6F;&#x4EF6;&#x8BBE;&#x8BA1;](.gitbook/assets/image%20%2893%29.png)

### 设计工程活动

![&#x8BBE;&#x8BA1;&#x5DE5;&#x7A0B;&#x6D3B;&#x52A8;](.gitbook/assets/image%20%2840%29.png)

### 设计模型

以**`需求分析阶段`**建立的**`数据模型, 功能模型 和行为模型`** 为**输入**, **设计阶段**会建立,**`数据设计, 架构设计, 接口设计, 组件设计.`**

* 设计模型分类
  * **数据设计**
  * **结构设计**
  * **接口设计**
  * **组件设计**

### 分析模型所得到的结果与设计模型的对应关系

![&#x76F8;&#x4E92;&#x5F71;&#x54CD;, &#x4E00;&#x5BF9;&#x591A;&#x6216;&#x591A;&#x5BF9;&#x591A;&#x5173;&#x7CFB;](.gitbook/assets/image%20%2885%29.png)

### 好的设计应该具有如下三个特点

* **正确的承上**
  * 正确传递分析模型的结果.
* **正确的启下**
  * 对软件开发后续过程的进行是有帮助的. 影响应该是正面的.
* **从实现的角度给一个完整的说明**
  * 通过设计方案能够准确的预期未来的产品形态.

![&#x4E09;&#x4E2A;&#x7279;&#x70B9;](.gitbook/assets/image%20%28143%29.png)

### 设计质量属性

* **功能性**
  * 指的是软件的功能要完整.符合用户的预期.
* **易用性**
  * 指的是 软件要好用,界面对用户友好.
* **可靠性**
  * 软件不易出错. 运行稳定
* **性能**
  * 主要是指 软件的吞吐率和响应时间等等,  能运行,而且运行流畅
* **可支持性**    \(又包含三个属性\)
  * `扩展性`
    * 是指 软件添加新的功能,或升级已有功能是否方便.
  * `适应性`
    * 是指 软件适应新的环境.,新的变化,是否容易.
  * `可维护性`
    * 是指 程序代码是否易懂, 软件维护期间的成本是否更小.

### 设计指导原则

* 设计方案要把软件的全貌勾勒出来, 不能一开始就跳跃**`细节`**
* 把大框架分解为**`小模块`**, 把复杂的**`大问题,`**分解为**`小问题`**来解决
* 设计的四个方面  :  **`数据`**, **`体系结构, 接口`** 和**`组件`** .
  * 应设计出 **`系统所用的数据结构.`**  **`展现独立功能特性的各组件`**, **`各组件的与外部环境的各接口.`**
* 设计由软件需求分析过程中获得信息驱动, 采用可重复使用的方法导出
* 设计应简单易易懂, 不要追求复杂的画图技巧.

## 设计相关的八大概念

### 设计相关概念

* **抽象**
* **体系结构**
* **设计模式**
* **模块化**
* **信息隐藏**
  * 把细节信息隐藏在接口之后
* **功能独立**
* **精化**
* **重构**

#### 1. 抽象

* **含义**
  * 忽略具体的信息, 将不同事物看成相同事物的过程.
* **抽象机制** 
  * 参数化, 规范化
* **规范化抽象**
  * **数据抽象**
    * 描述数据对象的冠名数据集合.
      * 例如抽象 **门** :  `静态数据,由一系列属性参数组成` : 门的类型, 转动方向, 开门机关, 重量和尺寸等.
  * **过程抽象**
    * 具有明确和有限功能的指令序列. 
      * 例如抽象 **开 :**  `一系列动作过程 :`走到门前,伸出手并抓住把手, 转动把手拉门, 离开打开的门 .等.

#### 2. 体系结构

  

* **体系结构定义** 
  * 软件的整体结构和这种结构了系统提供概念上完整性的方式.
* **体系结构设计 可以使用大量的一种或多种建模, 从不同的角度来表达**
  * **结构模型**
  * **框架模型**
  * **动态模型**
  * **过程模型**
  * **功能模型**

#### 3. 设计模式

* **设计模式 含义**
  * 是一种可复用的方案,能够为 一类相似的问题提供一种共同的解决方案, 减少重复求解的工作量.
* **设计模式分类, 和解决的问题**
  * **实体模式**
    * 解决的问题是:   一个静态的实体如何设计? 
  * **结构模式**
    * 解决的问题是:   实体之间的结构关系如何设计? 
  * **行为模式**
    * 解决的问题是:   实体的行为如何设计?

![&#x62BD;&#x8C61;&#x5DE5;&#x5382;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;](.gitbook/assets/image%20%28219%29.png)

#### 4. 模块化

* **含义**
  * 软件被划分为命名和功能相对独立的多个组件 \(通常称为模块\), 通过这些组件的集成来满足问题的需求.
* **软件的模块性** 
  * 程序可被智能管理的单一属性.
* **模块化的理论依据**
  * 基于人类解决问题的观测数据.

![&#x6A21;&#x5757;&#x5316;&#x548C;&#x8F6F;&#x4EF6;&#x6210;&#x672C;,  &#x5C31;&#x662F;&#x8BF4;&#x6A21;&#x5757;&#x4E0D;&#x80FD;&#x592A;&#x591A;&#x4E5F;&#x4E0D;&#x80FD;&#x592A;&#x5C11;](.gitbook/assets/image%20%28168%29.png)

* **模块化设计标准**
  * `模块化的分解性` 
    * 可分解为子问题
  * `模块化的组合性`
    * 组装可重用的组件
  * `模块化的可理解性`
    * 可作为独立单元理解
  * `模块化的连续性`
    * 需求小 变化只影响单个模块
  * `模块化的保护`
    * 模块内异常只影响自身

#### 5. 信息隐藏

* **信息隐藏原则** 
  * 模块应该具有彼此相互隐藏的特性
  * 即 : 模块定义和设计时应当保证模块内的信息 \(过程和数据\) 不可以被不需要这些信息的其他模块访问
* **特点**
  * 抽象有助于定义构成软件的过程 \(或信息\)实体
  * 抽象隐藏原则定义和隐藏了模块内的过程细节和模块内的本地数据结构.

#### 6. 功能独立

* **含义**
  * 每个模块只负责需求中特定的**`子功能,`** 并且从程序结构的其他部分看, 该模块具有简单的接口.
* **优点**
  * **易于开发** : 功能被划分,  接口被简化. 易于并行
  * **易于维护\(和测试\)** : 次生影响有限,  错误传递介绍, 模块重用
* **定性衡量标准**
  * **内聚性**   : 模块的功能相对强度
  * **耦合性**   : 模块之间的相互依赖程度
  * **模块独立性强 = 高内聚低耦合**

#### 7. 精化

* **含义**
  * 逐步求精的过程
* **与抽象的关系**
  * 抽象使设计师确定过程和数据, 但不局限于底层细节.
  * 精化有助于设计者在设计过程中揭示底层细节

#### 8. 重构

* **含义**
  * 不改变组件功能 和行为条件下,  简化组件设计\(或代码\) 的一种重组技术
* **方法**
  * 检查现有**`设计的冗余情况,`  `未使用的设计元素`,  `无效或不必要的算法`, `较差的构建方式或不恰当的数据结构,`** 或任何其他可被更改从而优化设计的问题.

## 四类设计技术概要

* **数据设计**
  * 数据是软件要操作和维护的信息对象,没有了数据,那么软件的运行将没有任何意义.
* **架构设计**
  * 表明软件的总体结构, \(和房子的框架设计一样\)
* **接口设计**
  * 不同的组件之间, 一定要有适配的 插头 和插座, 而且接口连接了系统不同的组成部分,
* **组件设计 \***
  * 功能的实现主要都在组件的内部去完成

### 数据设计

* **含义**
  * 数据设计  \(有时也被称为 数据架构\), 构件高层抽象 \(客户/用户的数据视图\) 的数据模型, 信息模型
* **相关概念**
  * 数据模型
    * 数据字典, E-R图, 类图
  * 数据结构
    * 计算机存储, 组织数据的方式
  * 数据库
    * 按照数据结构来组织,  存储和管理数据的仓库
  * 数据仓库
    * 更大规模组织的数据库,能更有利于信息分析和挖掘
* **在数据阶段, 主要用到的是 `数据模型`**, **`数据结构`** **和** **`数据库`**

### 组件级别的数据设计

**设计原则**

* 应用于功能和行为系统分析的原则也适用于数据设计.
* 所有的数据结构及其对应的操作都应该确定.
* 建立数据字典并在数据定义和程序设计中应用.
* 低层次的数据设计应该推迟到设计的后期过程.
* 数据结构的表示应该直接使用数据结构中数据的模块可见.
* 开发有用的数据结构及其对应操作的程序库.
* 软件设计和编程语言应该支持抽象数据类型的实现与定义.

### 概念数据模型

![&#x6982;&#x5FF5;&#x6570;&#x636E;&#x6A21;&#x578B;, &#x5BF9;&#x5B9E;&#x4F53;&#x548C;&#x5B9E;&#x4F53;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;&#x8FDB;&#x884C;&#x4E86;&#x8BF4;&#x660E;](.gitbook/assets/image%20%28164%29.png)

### 物理数据模型

![&#x4F4E;&#x5C42;&#x7269;&#x7406;&#x6570;&#x636E;&#x6A21;&#x578B;. &#x9700;&#x8981;&#x7ED3;&#x5408;&#x5177;&#x4F53;&#x7684;&#x6570;&#x636E;&#x5E93;&#x548C;&#x6570;&#x636E;&#x7C7B;&#x578B;&#x6765;&#x8BF4;&#x660E;](.gitbook/assets/image%20%2844%29.png)

### 体系结构设计

* 系统需要执行的函数功能组件集 \(入数据库, 计算模块 \)
* 组件之间通信, 协同和合作的连接器.
* 组件集成构成系统的约束.
* 设计人员通过分析系统组成部分的已知特性, 理解其整体特性的语义模型分析.

### 风格和模式简要分类 -- 数据中心架构

![&#x6570;&#x636E;&#x4E2D;&#x5FC3;&#x67B6;&#x6784;](.gitbook/assets/image%20%28165%29.png)

* 在这个架构中, 数据存储是整个架构的中心.
* 所有的客户端软件相互之间没有交互.
* 只能通过与信息存储的交互 , 来实现信息的共享.

**数据中心架构 主要应用在 :   数据库系统,  超文本系统,  黑板系统, 在线协同文档处理 ,等等**

### 风格和模式简要分类  -- 数据流体系架构

![&#x6709;&#x7BA1;&#x9053;&#x548C;&#x8FC7;&#x6EE4;,  &#x6279;&#x5904;&#x7406;&#x5E8F;&#x5217; &#x4E24;&#x5927;&#x7C7B;](.gitbook/assets/image%20%2846%29.png)

**主要用在 : 音频处理; 图形处理;  批处理则是程序编译.**

### 风格和模式简要分类  -- **调用和返回架构**

![&#x4ECE;&#x6839;&#x8282;&#x70B9;m &#x5F00;&#x59CB;, &#x8C03;&#x7528;&#x5B50;&#x6A21;&#x5757;, &#x7136;&#x540E;&#x6700;&#x5E95;&#x5C42;&#x7684;&#x5B50;&#x6A21;&#x5757;&#x518D;&#x9010;&#x5C42;&#x5411;&#x4E0A;&#x4F20;&#x9012;](.gitbook/assets/image%20%28159%29.png)

### 风格和模式简要分类  -- **层次架构**

![](.gitbook/assets/image%20%2878%29.png)

将软件从内到外分成了很多层, 最里面是核心层, 用户的要求 最终会从内到外的实现,并从内到外的返回结果.

**主要应用就是操作系统.**

### 风格和模式简要分类  -- 面向对象架构 

![&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x67B6;&#x6784;, &#x76EE;&#x524D;&#x6700;&#x5E38;&#x7528;&#x7684;&#x67B6;&#x6784;](.gitbook/assets/image%20%2891%29.png)

* 模型   用于管理数据对象.
* 视图   用于界面的表示.
* 控制器   响应视图请求,并更新模型与视图.

### 体系结构组织与细化

* 两个基本问题
  * **控制结构**
    * 在架构内如何实现管理控制?
    * 是否有不同控制架构存在?
  * **数据传递**
    * 组件之间如何进行数据传递?
    * 数据流是否连续, 或者传递给系统的数据对象是否零散?

### 部署设计

**需要全盘考虑先前设计方案, 与 QoS需求, 平衡取舍相关问题的成本,以实现最佳解决方案.**

**提前考虑软件的部署, 也有助于提早发现环境对软件带来的约束, 从而从设计阶段考虑相应的解决办法.**

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;](.gitbook/assets/image%20%28198%29.png)

### 部署设计输出

输出包含 **`部署架构, 实现规范, 实施计划`**  三大部分.

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;&#x8F93;&#x51FA;](.gitbook/assets/image%20%28167%29.png)

### 部署设计方法

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;&#x65B9;&#x6CD5;](.gitbook/assets/image%20%2864%29.png)

### 接口设计  \(含界面设计\)

* **接口设计主要包含  内部接口的设计 和 外部接口的设计 两个方面.**
  * **内部接口的设计**  主要是指内部模块之间进行通信的接口设计,一般会作为架构设计 或组件设计的一部分  同时进行.
  * **外部接口的设计**  包括人机接口以及系统与外部系统的接口.
* **界面设计 \(GUI\)  高效用户界面设计有三条重要原则:**
  * 允许用户操纵控制 \(用户为中心\)
  * 减少用户记忆负担
  * 保持界面一致
* **环境分析 确定了用户接口操纵的物理结构和社会结构.**

### 组件设计\*

* **面向过程的组件设计**
  * 函数与模块的设计内容
* **面向对象的组件设计**
  * 类与操作的设计内容

## 面向过程的总体设计

### 结构化的总体设计方法

* 首先研究, 分析 和审查 数据流图.  从软件的需求规格说明中弄清数据加工的过程, 对于发现的问题及时解决.
* 然后根据数据流图决定问题的类型.  数据处理问题典型的类型有两种:  变换型和事物型. 针对两种不同的类型分别进行分析处理.
* 由数据流图导出系统的初始化结构图.  **这个系统结构图是最重要的部分**
* 利用一些启发式原则来改进系统的初始化结构图, 知道得到符合要求的结构图为止
* 修改和补充数据词典.

### 在系统结构图中的模块

* **传入模块**
  * 它从**`下属模块`**取得数据,  经过某些数据, 再将其传送给**`上级模块`**.  **他传送的数据流叫做`逻辑输入数据流`.**
* **传出模块**
  * 它从**`上级模块`**取得数据, 进行某些处理, 再将其传送给**`下属模块`**.  **他传送的数据流叫做`逻辑输出数据流`.**
* **变换模块**
  * 它从**`上级模块`**取得数据, 进行特定的处理, 转换成其他形式, 在传送回**`上级模块`**. 它加工的数据流叫做**`变换数据流.   (数据从哪里来,就返回哪里去)`**
* **协调模块**
  * 对所有**`下属模块`**进行协调和管理的模块.

![&#x4F20;&#x5165;&#x6A21;&#x5757;, &#x4F20;&#x51FA;&#x6A21;&#x5757;, &#x53D8;&#x6362;&#x6A21;&#x5757;, &#x534F;&#x8C03;&#x6A21;&#x5757;](.gitbook/assets/image%20%28122%29.png)

### 变换型系统结构图

* 变换型数据处理问题的工作大致分为**三步**,即  **`取得数据, 交换数据 和 给出数据`**.
* 相应于 **`取得数据, 变换数据, 给出数据`** , **变换型系统构造图由`输入, 中心变换 和 输出`**等三部分组成.

![&#x53D8;&#x6362;&#x6027;&#x4F53;&#x7CFB;&#x7ED3;&#x6784;&#x56FE;](.gitbook/assets/image%20%28105%29.png)

### 事务性系统结构图

* 它接受一项书屋, 根据事务处理的特点和性质, 选择分派一个适当的处理单元, 然后给出结果.
* 在事物型系统结构图中, **`事务中心模块`** 按所接受的事物的类型,  选择某一事务处理模块执行. 各事**`务处理模块`** 并列. 每个事务处理模块可能要调用若干个**`操作模块`**, 而操作模块又可能调用若干个**`细节模块.`**

![&#x4E8B;&#x52A1;&#x6027;&#x7CFB;&#x7EDF;&#x7ED3;&#x6784;&#x56FE;](.gitbook/assets/image%20%28173%29.png)

### 变换型 与 事务性 分析

#### 变换性分析

* 是从数据流图推倒出变换型 体系结构 的过程
  * **第一步是** **`重画数据流图`**
  * **第二步是** **`区分有效(逻辑) 输入, 有效(逻辑) 输出 和中心变换部分`**
  * **第三步是 进行一级分解, 设计上层模块**
  * **第四步是 `进行二级分解, 设计输入, 输出 和 中心变换部分的中, 下层模块.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41;&#x56FE;, &#x4E0B;&#x9762;&#x662F;&#x6839;&#x636E;&#x6570;&#x636E;&#x6D41;&#x56FE;&#x91CD;&#x753B;&#x7684;&#x53D8;&#x6362;&#x578B;&#x6570;&#x636E;&#x6D41;&#x56FE;](.gitbook/assets/image%20%28202%29.png)

#### 变换分析注意事项

* **深度遍历模块设计**
  * 在选择模块设计的次序时,必须对一个模块的全部直接下属模块都设计完成之后, 才能转向另一个模块的下层模块的设计.
* **耦合与内聚**
  * 在设计下层模块时, 应考虑模块的耦合和内聚问题, 以提高初始结构图的质量.
* **使用 "黑箱"  技术**
  * 在设计当前模块时, 先把这个模块的所有下层模块定义成 "黑箱", 在设计中利用它们时, 暂时不考虑其内部结构和实现. 在这一步定义好的 "黑箱" , 在下一步就可以对他们进行设计和加工. 这样, 又导致更多的 "黑箱". 最后, 全部 "黑箱" 的内容结构应完全被确定.
* **控制直接下属的模块数**
  * 在模块划分时, 一个模块的直接下属模块一般在5个左右. 如果下属模块超过10个, 可设立中间层次.
* **停止模块功能分解的情况**
  * 模块不能再分析称为明显的子任务.
  * 分解成用户提供的模块或程序库的子程序;
  * 模块的界面是输出 /  输出设备传送的信息;
  * 模块不易再分解得过小.



#### 事务性分析

* 在很多软件应用中, 存在某种软件数据流, 他可以引发一个或多个处理, 这些处理能够完成该作业要求的功能. 这种**数据流**就叫做**`事务`.  \(可以把一个界面的主控台 看成是事务的中心\)**
* 和变换分析一样, 事务分析也是从分析数据流图开始**`, 自顶向下, 逐步分解, 建立系统结构图.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41; , &#x4E0B;&#x9762;&#x662F;&#x4E8B;&#x52A1;&#x5206;&#x6790;&#x540E;&#x7684;&#x6570;&#x636E;&#x6D41;,  4 5  6 &#x7684;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4F1A;&#x8FD4;&#x56DE;&#x7ED9;&#x4E3B;&#x63A7;, &#x7136;&#x540E;&#x518D;&#x7531;&#x4E3B;&#x63A7;&#x8F93;&#x51FA;](.gitbook/assets/image%20%28205%29.png)

#### 事务型分析过程

该过程自顶向下 依次执行

* **识别事务源**
  * 利用数据流图和数据字典, 从问题定义和需求分析的结果中, 找出各种需要处理的事务, 通常, 事务来自物理输入装置. 有时, 设计人员还必须区别 **`系统的输入, 中心加工 和 输出`**中产生的事务.
* **规定适当的事务性结构**
  * 在确定了该数据流图具有事务性特征之后, 根据模块划分理论, 建立适当的事务性结构.
* **识别各种事务和他们定义的操作**
  * 从问题定义和需求分析中找出的**`事务及其操作必须的全部信息,`** 对于系统内部产生的事务, **必须仔细的定义他们的操作.**
* **注意利用公共模块**
  * 在事务分析的过程中, 如果不同事务的一些中间模块可由具有类似的语法和语义的若干个底层模块组成, 则可以把这些底层模块构造成`公共模块.`
* **事务处理模块**
  * 对每一事务, 或对联系密切的一组事务, **`建立一个事务处理模块`**; 如果发现在系统中有类似的事务, 可以把他们**`组成一个事务处理模块`**.
* **操作模块**
  * 对事务处理模块规定 他们全部的下层**`操作模块.`**
* **细节模块**
  * 对操作模块规定 他们的全部**`细节模块`**.

![&#x4E8B;&#x52A1;&#x578B;&#x5206;&#x6790;&#x8FC7;&#x7A0B;](.gitbook/assets/image%20%28127%29.png)

### 混合结构分析

* **变换分析是软件系统结构设计的主要方法.**
  * 一般一个大型的软件系统是**`变换型结构`**和**`事务性结构`**和**`混合结构.`**
* **所以, 我们通常利用以 `变换分析为主, 事务分析为辅` 的方式进行软件结构设计.**

![&#x6DF7;&#x5408;&#x6A21;&#x578B;&#x7684;&#x6848;&#x4F8B;, &#x4E8B;&#x52A1;&#x6027;&#x548C;&#x53D8;&#x6362;&#x578B;](.gitbook/assets/image%20%2847%29.png)

### 面向过程的组件设计之 流程图

#### 结构化的组件设计

* 组件设计也称为**`过程设计,详细设计, 位于数据设计`**,  **是位于`体系结构设计 和接口设计`**完成之**`后`**进行设计的.
* **对于结构化组件设计来说, 任何程序总可以用三种结构化的构成元素来设计和实现.**
  * **顺序 :** 任何算法规约中的核心处理步骤.  也就是从前往后的处理步骤.
  * **条件:** 允许根据逻辑情况选择处理的方式, 也就是判断
  * **重复:** 提供了循环
* **详细设计的工具可以分为以下三类**
  * **图形设计符号:**    **`流程图, 盒图, 等`**
  * **表格设计符号:**    **`决策表 ,等`**
  * **程序设计语言**:    **`PDL 等`**



#### 流程图

利用各种**`方块图形, 线条, 及箭头`**等符号来表达解决问题的步骤及进行的**`顺序`**;  **`是算法的一种表示方式`**

* **常见的两种流程图**
  * **标准作业流程 \(SOP , Standard  operating procedure\)**
    * 企业界常用的一种作业方法, 其目的在使每一项作业流程均能清楚呈现, 任何人只要看到了流程图, 便能一目了然, 有助于相关作业人员对整体工作流程的掌握.
  * **程序流程图 \(program flow chart\)**
    * 表示程序中的处理过程.

#### 流程图的优点

* 所有流程一目了然, 工作人员能掌握全局.
* 更换人手时, 按图索意, 容易上手.
* 所有流程在绘制时, 很容易发现疏失之处, 可适时予以调整更正, 使各项作业更为严谨.

#### 流程图的基本符号

![&#x6D41;&#x7A0B;&#x56FE;&#x7684;&#x57FA;&#x672C;&#x7B26;&#x53F7; 1 ](.gitbook/assets/image%20%2834%29.png)

![&#x6D41;&#x7A0B;&#x56FE;&#x7684;&#x57FA;&#x672C;&#x7B26;&#x53F7; 2](.gitbook/assets/image%20%28211%29.png)

#### 流程图的基本结构

* **顺序结构 \(Sequence\)**
  * 处理程序顺序进行, 用控制流来连接处理的程序
* **选择结构\(selection\)**
  * **二元结构** \(基本结构\)
    * 流程依据某些条件, 依条件是否成立, 分别进行不同处理程序.
  * **多重选择结构**
    * 可以根据一个条件的取值, 选择不同的分支进行处理,   与二元结构的区别 就是处理数目不同.
* **循环结构\(Iteration\)**
  * while - do 结构
  * do - while 结构

#### 流程图结构 - 顺序结构

![&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x987A;&#x5E8F;&#x8FDB;&#x884C;,&#x7528;&#x63A7;&#x5236;&#x6D41;&#x6765;&#x8FDE;&#x63A5;](.gitbook/assets/image%20%28193%29.png)

#### 流程图结构 -选择结构  - 二元选择结构

![&#x6D41;&#x7A0B;&#x4F9D;&#x636E;&#x67D0;&#x4E9B;&#x6761;&#x4EF6;, &#x4F9D;&#x6761;&#x4EF6;&#x662F;&#x5426;&#x6210;&#x7ACB;, &#x5206;&#x522B;&#x8FDB;&#x884C;&#x4E0D;&#x540C;&#x5904;&#x7406;&#x7A0B;&#x5E8F;](.gitbook/assets/image%20%2868%29.png)

#### 流程图结构 -选择结构  - 多重选择结构

![&#x6BD4;&#x4E8C;&#x5143;&#x7ED3;&#x6784; &#x591A;&#x4E86;&#x5F88;&#x591A;&#x5224;&#x65AD;&#x6761;&#x4EF6;](.gitbook/assets/image%20%28144%29.png)

#### 流程图结构 - 循环结构 - while do 结构

![while do &#x7ED3;&#x6784;](.gitbook/assets/image%20%28138%29.png)

#### 流程图结构 - 循环结构 - do while  结构

![do while &#x7ED3;&#x6784;](.gitbook/assets/image%20%2876%29.png)

#### 流程图绘制原则

1. 各项步骤有选择或决策结构, 入 "可/否" ,  "通过/不通过" , 或其他相对文字时, 请检查校正流程是否有遗漏, 以避免悬而未决的状况.
2. 流程图符号绘制排列顺序, 为由上而下, 由左而右.
3. 处理程序可用阿拉伯数字, 从1开始, 依处理程序排列顺序编号, 并以文字处理程序功能命名. ![](.gitbook/assets/image%20%28133%29.png) 
4. 相同流程图符号 应该一大小一致.
5. 路径符号应该避免相互交叉.  

   ![](.gitbook/assets/image%20%28180%29.png)

6. 同一路径符号的指示箭头应只有一个  

   ![](.gitbook/assets/image%20%28212%29.png)

7. 开始符号在流程图中只能出现一次, 但结束符号则不限. 若流程图能一目了然, 则开始符号和结束符号可以省略.
8. 选择结构与重复结构的选择与决策条件, 文件叙述应简明清晰, 路径加注 "是", "否" 或其他相对性文字指示说明.
9. 流程图中若有参考到其他已定义流程, 可使用定义处理程序符号, 不必重复绘制.  

   ![](.gitbook/assets/image%20%28126%29.png)

10. 流程图若一页绘制不下, 可以使用分级分页绘制方式, 并在处理程序编号上表示其级别.  

    ![](.gitbook/assets/image%20%2859%29.png)\*\*\*\*

**示例 : 输出 0~9 的数**

![do while &#x7684;&#x5FAA;&#x73AF;&#x7ED3;&#x6784;](.gitbook/assets/image%20%28204%29.png)

**示例 : 输入5个实数, 计算平均值, 然后再打印该平均值**

![&#x5FAA;&#x73AF;&#x8F93;&#x5165;&#x548C;&#x6587;&#x4EF6;&#x6253;&#x5370;](.gitbook/assets/image%20%28142%29.png)

**示例:收邮件**

![&#x5F88;&#x590D;&#x6742;](.gitbook/assets/image%20%28207%29.png)

### 面向过程的其他组件设计方法

#### 盒图 \(N-S图\)

![&#x548C;&#x6D41;&#x7A0B;&#x56FE;&#x5F88;&#x50CF;,  UNTIL &#x662F; do while &#x578B;](.gitbook/assets/image%20%28218%29.png)

**盒图示例**

![&#x793A;&#x4F8B;](.gitbook/assets/image%20%284%29.png)

#### **PDL \(程序设计语言\)**

* PDL 是一种用于描述功能模块的算法设计和加工系统的语言. 简称**程序设计语言**. **它是一种`伪码`.**
* 伪码的语法规则范围 "**`外语法`**" 和 "**`内语法`"**
* PDL具有**`严格关键字外语法`**, 用于定义控制结构和数据结构, 同时它的表示实际操作和条件的内语法又是灵活自由的. 可使用自然语言的词汇.

**PDL示例:  拼词检查程序**

![&#x53F3;&#x4FA7;&#x7684;&#x7EA2;&#x8272;&#x90E8;&#x5206;&#x662F;&#x6CE8;&#x89C6; ,&#x800C;&#x4E14;&#x6807;&#x6CE8;&#x7684;&#x662F;&#x5DE6;&#x8FB9;&#x7684;&#x6E90;&#x7801;](.gitbook/assets/image%20%28217%29.png)

#### 判定表 \(决策表\)

* **`判定用于表示程序静态逻辑.`**
* 在判定表中的**`条件部分`**给出所有的两分支判断的列表, **`动作部分`**给出相应的处理.
* 要求将程序流图中的多分支判断都改成**`两分支`**判断.

主要用在软件测试里. 用来判断 输出,输入,动作 是否都符合预期.

![&#x6761;&#x4EF6;&#x90E8;&#x5206;&#x548C;&#x52A8;&#x4F5C;&#x90E8;&#x5206;](.gitbook/assets/image%20%28131%29.png)

#### 无多分支流程图 -&gt; 判定图

![- &#x4EE3;&#x8868;, Y &#x548C;&#x975E;Y &#x7ED3;&#x679C;&#x5982;&#x4F55; &#x4ED6;&#x90FD;&#x4F1A;&#x6267;&#x884C;, &#x6BD4;&#x5982; &#x7B2C;&#x4E00;&#x6570;&#x5217;&#x7684; c,d,e,g,h](.gitbook/assets/image%20%289%29.png)



## 面向对象的架构设计

**面向对象的架构设计是面向对象设计的活动之一.**

* **面向对象设计活动包括如下几个设计**
  * **用例设计**
  * **类设计**
  * **数据库设计**
  * **用户界面设计**
  * **系统架构设计 \***

### 面向对象设计活动之一 : 架构设计

* **`架构设计的 目的`** 是勾画出系统的总体结构,  这项工作由经验丰富的架构设计师主持完成.
* **`输入:`**  分析模型阶段所产生的  **用例模型, 分析模型.**
* **`输出:`**  **系统的物理结构, 子系统及其接口, 概要的设计类.**

![&#x5206;&#x6790;&#x6A21;&#x578B;&#x4E0E;&#x8BBE;&#x8BA1;&#x6A21;&#x578B;&#x548C;&#x5B9E;&#x65BD;&#x6A21;&#x578B;&#x5173;&#x7CFB;&#x7684;&#x793A;&#x610F;&#x56FE;](.gitbook/assets/image%20%28182%29.png)

### 架构设计步骤

#### 第一步 :构造系统的物理模型

* 首先用 **UML** 的配置图 \(部署图\)  **`描述系统的物理架构.`**
* **`将需求分析阶段捕获的系统功能分配到这些物理节点上. 从而将程序的 软件部分和 承载软件的硬件部分 联系到一起.`**
* 配置图上可以显示**`计算节点的拓扑结构, 硬件设备配置, 通信路径, 各个节点上运行的系统软件配置 , 应用软件配置.`**

**一个图书馆信息管理的物理模型, 如图显示.**

![&#x90E8;&#x7F72;&#x56FE;&#x7684;&#x4F8B;&#x5B50;](.gitbook/assets/image%20%2839%29.png)

#### 第二步 : 设计子系统

* 对于一个复杂的软件系统来说, 将其分解成若干个子系统, 子系统内还可以继续划分 子系统或包, 这种自顶向下, 逐步细化的组织结构非常符合人类分析问题的思路.
* 每个子系统与其它子系统之间应该定义接口, 在接口上说明交互信息, 注意这时还不要描述子系统的内部实现.
* 可用 UML 组件图表示 子系统的功能.

**\(1\). 划分各个子系统的方式:**

* **按功能划分**, `将相似的功能组织在一个子系统中; (例如增删改查 可以划分到修改系统中)`
* **按照系统的物理布局划分**, `将在同一个物理区域内的软件组织为一个子系统.`
* **按照软件层次划分子系统**, `软件层次通常可划分为用户界面层, 专用软件层, 通过软件层, 中间件层和 数据层` .

![&#x5BF9;&#x56FE;&#x4E66;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;&#x8FDB;&#x884C;&#x5B50;&#x7CFB;&#x7EDF;&#x7684;&#x5212;&#x5206;, &#x6309;&#x7167;&#x8F6F;&#x4EF6;&#x5C42;&#x6B21;&#x5212;&#x5206;&#x5B50;&#x7CFB;&#x7EDF;](.gitbook/assets/image%20%2829%29.png)

**\(2\). 定义子系统之间的关系:**

* 划分子系统后, 要确定子系统之间的关系如下:
  *  "**`请求 - 服务`**" **关系**,   "**`请求`**" **子系统调用** "**`服务`**" **子系统,**  "**`服务`**" **子系统**完成一些服务, 并且将结果返回给 "**`请求`**"**子系统**;
  * **`平等关系,  每个子系统都可以调用其他子系统.`**
  * **如果子系统的内容相互有关联,** `就应该定义它们之间的依赖关系`.  **在设计时, 相关的子系统之间应该定义接口**, `依赖关系应该指向接口` **而不要指向子系统的内容**
* **但是要注意**, 如果两个子系统之间的关系过于密切, 则说明一个子系统的变化会导致另一个子系统变化, 这种子系统理解和维护都比较困难.
  * **解决子系统之间关系过于密切的办法基本上有两个:**
    * **`重新划分子系统,`** 这种方法比较简单, 将子系统的粒度减少, 或者重新规划子系统的内容, 将相互依赖的元素划归到一个子系统之中.
    * **`定义子系统的接口, 将依赖关系定义到接口上.`**

**\(3\). 定义子系统的接口:**

* 每个子系统的接口上定义了若干操作, 体现了子系统的功能, 而功能的具体实现方法应该是隐藏的, 其他子系统只能通过接口间地享受这个子系统提供的服务, 不能直接操纵它.



#### 第三步 :非功能需求设计

* 分析阶段定义了整个系统的非功能需求, 在设计阶段要研究这些需求, 设计出可行的方案.
* **非功能需求包括 :** 
  * **`系统的安全性, 错误检测和故障恢复,  可移植性 和 通用性等等.`**
* 具有共性的非功能需求一般设计在**`中间层和通用应用层`**, **目的**是`充分利用已有构件, 减少重新开发的工作量.`



### 面向对象设计活动之二 : 进一步细化用例

**这个步骤是 `架构设计活动 完成`之后进行的.**

* **根据分析阶段产生的`高层类图`和`交互图`,** 由**`用例设计师`**研究已有的类, 将它们分配到相应的**`用例`**中.
* 检查每个用例功能, 依靠当时的类能否实现, 同时检查每个**`用例`**的特殊需求是否有合适的类来实现
* 细化每个用例的类图, 描述实现**`用例的类`** 及其 **`类之间的相互关系`**, 其中的通用类和关键类可用粗线框区分,  **`这些类将作为项目经理检查项目时的重点`.**

#### 细化用例

* **第一步** : 通过扫描用例中所有的交互图识别参与用例解决方法的类. 在设计阶段完善类, 属性和方法. 例如 , 每个用例至少应该有一种控制类, 他们通常没有属性而只有方法,  它本身不完成什么具体的功能, 只是起协调和控制作用.
  * 每个类的方法都可以通过分析交互图得到, 一般的检查所有的交互图发送给某个类的所有消息, 这表明了该类必须定义的方法. 例如 "借书控制" 类向 "读者" 类 发送 "检查读者\(读者编号\)" 消息, 那么 "检查读者" 就作为 "读者" 类 应该提供的方法.
* **第二步 :** 添加属性的类型, 方法的参数类型和方法的返回类型.
* **第三步:** 添加类之间的关系, 包括关联, 依赖 ,继承等.

![&#x7C97;&#x7EBF;&#x6846;&#x8868;&#x793A;&#x63A7;&#x5236;&#x7C7B;, &#x659C;&#x4F53;&#x5B57;&#x754C;&#x9762;&#x7C7B;, &#x6B63;&#x5E38;&#x7684;&#x8868;&#x793A;&#x5B9E;&#x4F53;&#x7C7B;](.gitbook/assets/image%20%28203%29.png)

### 类

**类是包含信息和影响信息行为的逻辑元素, 类的符号是由三个格子的长方形组成, 有时下面两个格子可以省略.**

**`最顶部`**的格子包含类的名字, 类的命名应该用应用领域中的术语, 有明确的含义, 以利于开发人员与用户的理解和交流.  **`中间的`**格子说明类的属性. **`最下面`**的格子是类的操作行为.

![&#x7C7B;&#x8868;&#x8FBE;&#x5F62;&#x5F0F;](.gitbook/assets/image%20%28161%29.png)

* 类的关系 一般有五种 最常见
  * **关联关系**
  * **泛化关系**
  * **依赖关系**
  * **组合关系**
  * **聚合关系**

![&#x7C7B;&#x7684;&#x5173;&#x7CFB;&#x548C;&#x8868;&#x793A;&#x7B26;&#x53F7;\(&#x7BAD;&#x5934;\)](.gitbook/assets/image%20%28137%29.png)

![&#x5206;&#x6790;&#x7C7B;&#x56FE;, &#x4E00;&#x822C;&#x5B58;&#x5728;&#x4E8E;&#x9700;&#x6C42;&#x5206;&#x6790;&#x9636;&#x6BB5;,\(&#x4E3B;&#x8981;&#x6709;&#x4E09;&#x79CD;\)](.gitbook/assets/image%20%2816%29.png)

* **实体类**
  * 是对事务对象的一个建模, 在分析阶段出现的实体 都会用实体类来表示.
* **控制类**
  * 用于控制业务逻辑, 它会实现一些控制的功能.
* **边界类**
  * 存在于外部系统 和 系统之间以及不同的组件之间.

#### 如何找实体类

* 实体类用于对 **`必须存储的信息和相关信息`** 进行建模.
* 实体类源于业务模型中的**`业务实体`**, 但出于对系统结构的优化, 可以在后续的过程中被拆分, 合并.

#### 如何找边界类

* **`参与者与用例之间`**应当建立边界类.
* **`用例与用例之间`**如果有交互, 应当为其建立边界类.
* 如果 **`用例与系统边界之外的非人对象`** 有交互, 应当为其建立边界类.
* 在**`相关联的业务对象有明显的独立性要求,`** 即它们可能在各自的领域内发展和变化, 但又希望互不影响时, 也应当为它们建立边界类.

#### 如何找控制类

* 控制类来源于对 **`用例场景中动词`** 的分析和定义.
* 控制类主要起到协调对象的作用,例如从边界类通过控制类访问实体类, 或者实体类通过控制类访问另一个实体类.
* 如果 用例 场景中的行为在执行步骤, 执行要求 或者 执行结果上具有类似的特征, 应该合并或抽取超类.

![&#x7C97;&#x7EBF;&#x6846;&#x8868;&#x793A;&#x63A7;&#x5236;&#x7C7B;, &#x659C;&#x4F53;&#x5B57;&#x754C;&#x9762;&#x7C7B;, &#x6B63;&#x5E38;&#x7684;&#x8868;&#x793A;&#x5B9E;&#x4F53;&#x7C7B;](.gitbook/assets/image%20%28147%29.png)

### 面向对象设计活动之三 : 详细设计一个类

![&#x8BBE;&#x8BA1;&#x6BCF;&#x4E2A;&#x7C7B;&#x7684;&#x5C5E;&#x6027;,&#x65B9;&#x6CD5;&#x548C;&#x5173;&#x7CFB;](.gitbook/assets/image%20%2842%29.png)

#### 类设计第1步 : 定义类的属性

* **用所选择的变成语言定义每个类的属性, 类的属性反应类的特性, 通常属性是被封装在类的内部, 不允许外部对象访问.**
* **注意点:**
  * 分析阶段和概要设计阶段定义的一个类属性在详细设计时可能要被分解为多个, **`减小属性的表示粒度`** 有利于实现和重用.  但是一个类的属性如果太多, 则应该检查一下, 看能否分离出一个新的类.
  * 如果一个类因为其属性的原因变得复杂而难以理解, 那么就将一些属性 **`分离出来形成一个新的类.`**
  * 通常不同的编程语言提供的数据类型有很大差别, 确定类的属性时要用编程语言来约束可用的属性类型. 定义属性类型时 **`尽可能使用已有的类型`**, 太多的自定义类型会降低系统的可维护性 和 可理解性 等性能指标.
  * 类的属性结构要**`坚持简单的原则,`** 尽可能不使用复杂的数据结构.

#### 类设计第2步 : 定义类的操作

* **由构件工程师为每个类的方法设计必须实现的操作, 并用自然语言或伪代码描述操作的实现算法. 一个类可能被应用在多个用例中, 由于它在不通用例中担当的角色不同,  所以设计时要求详细周到.**
* **注意事项:**
  * 分析类的每个**`职责`**的具体含义, 从中找出类应该具备的操作.
  * 阅读类的**`非功能需求说明`**, 添加一些必要的操作.
  * **`确定类的接口 应该提供的操作. 这关系到设计的质量, 特别是系统的稳定性, 所以确定类接口操作要特别小心.`**
  * 逐个检查类在每个用例实现中是否合适, 补充一些**`必要的操作.`**
  * 设计时不仅要考虑到系统正常的运行情况,  还要考虑一些**`特殊情况`**, 如中断/错误处理等.

#### 类的设计第3步 :定义类之间的关系

* **`设置基数 : 一类的实例与另一个类的实例之间的关系`.  在图书馆信息管理系统中, "`图书`" 类 和 "`读 者`" 类关联, 如果需求说明有 "`以为读者可借图书的数量为0至10本`", 那么它们之间的基数为 `1: 0 ...10`;**
* **`使用关联类: 可以放置与关联相关的属性.`**  例如 "图书" 类  和 "读者" 类, 如果要反应读者的借书情况, 该如何处理呢? 可创建一个关联类, 这个类中的属性是 "借书日期".

![&#x56FE;&#x4E66;&#x53EF;&#x88AB;&#x591A;&#x4E2A;&#x8BFB;&#x8005;&#x501F;&#x9605;, &#x8BFB;&#x8005;&#x4E5F;&#x53EF;&#x4EE5;&#x501F;&#x9605;&#x591A;&#x79CD;&#x56FE;&#x4E66;](.gitbook/assets/image%20%28153%29.png)



### UML顺序图

* **`顺序图是强调信息时间顺序的交互图.`**
* **`顺序图描述了对象之间传达信息的时间顺序, 用来表名用例中的行为顺序.`**
* **`顺序图将交互关系表示为一个二维图.`**  即在图形上, 顺序图是一张表, **其中显示的对象沿横轴排列, 从左到右分布在图的顶部**; `而消息则沿纵轴按时间顺序排序`. 创建顺序图时, 能够使图尽量简洁为依据布局.

![&#x793A;&#x4F8B;](.gitbook/assets/image%20%28199%29.png)

1. **矩形框**   代表的是对象或者类
2. 类和对象会从左到右的排列
3. 消息是沿着自上而下的顺序去发送和接收

### 在什么时候用到顺序图

![](.gitbook/assets/image%20%2827%29.png)

### 顺序图的组成

* **顺序图包含 4 个元素**
  * **对象\(object\)**
    * 对象可以由类来替换, 使用系统的参与者也可以作为一种特殊的对象放置于数据图的顶部.
  * **生命线\(Lifeline\)**
    * 是指对象或者类\(长方框\)下方的长虚线, 在长方框用以强调这个部分处于活动的状态.
  * **消息\(Message\)**
    * 带箭头的实线表示的是消息.
  * **激活 \(Activation\)**
    * 将该对象的生命线拓展成矩形, 其中的矩形称为激活条\(期\)或控制器.

![&#x987A;&#x5E8F;&#x56FE;&#x7684;&#x7EC4;&#x6210;](.gitbook/assets/image%20%2875%29.png)

### 顺序图中的对象

* **顺序图中的对象的符号和对象图中所用的符号一样.**
* **`将图像置于顺序图的顶部意味着在交互开始的时候对象就已经存在了`**, **`如果对象的位置不在顶部, 那么表示对象是在交互的过程中被创建的`**`.`
* ![](.gitbook/assets/image%20%28174%29.png) 

### 顺序图中的 参与者和对象

* **参与者和对象按照从左到右的顺序排列**
* **一般最多两个参与者, 他们分列两端. `启动这个用例的参与者往往排在最左边`; `接收消息的参与者则排在最右端`;**
* **对象从左到右按照重要性排列或按消息先后顺序排列.**

![&#x5BF9;&#x8C61;&#x7684;&#x6392;&#x5E8F;&#x89C4;&#x5219;](.gitbook/assets/image%20%28191%29.png)

![&#x5BF9;&#x8C61;&#x7684;&#x547D;&#x540D;&#x7684;&#x4E09;&#x79CD;&#x65B9;&#x5F0F;](.gitbook/assets/image%20%2831%29.png)

### 顺序图中的 生命线

* 每个对象都有自己的生命线, 用来表示在该用例中一个对象在一段时间内的存在.
* 生命线使用垂直的虚线表示
* 如果对象生命期结束, 则用注销符号表示
* 对象磨人的位置在图顶部, 表示对象在交互之前已经存在.
* 如果交互过程中由另外的对象所创建, 则位于图的中间某处.

![&#x76EE;&#x6807;&#x5BF9;&#x8C61;&#x5728;new\(\)&#x4E4B;&#x540E;&#x751F;&#x4EA7;, &#x7136;&#x540E; delete\(\) &#x4E4B;&#x540E;&#x5220;&#x9664;](.gitbook/assets/image%20%2832%29.png)

### 顺序图中的 激活

* **激活表示该对象被占用以完成某个任务,** `去激活指的则是对象处于空间状态`, 在等待消息.
* **`在UML中, 为了表示对象是激活的, 可以将该对象的生命线拓宽成矩形. 其中的矩形称为 激活条(期) 或控制期, 对象就是在激活条的顶部被激活的, 对象在完成自己的工作后被 去激活.`**

![&#x6FC0;&#x6D3B;&#x56FE;&#x793A;](.gitbook/assets/image%20%2817%29.png)

#### 激活期

* 当一条消息被传递给对象的时候, 它会除法该对象的某个行为, **这时就说该对象被激活了**.
* **在 UML中, 激活用一个在生命线上的细长矩形框表示.**
* **矩形本身被称为对象的激活器或控制期, 对象就是在激活期顶端被激活的.**
* **`激活期说明对象正在执行某个动作`**. 当动作完成后, **`伴随着一个消息箭头离开对象的生命线, 此时对象的一个激活期也宣告结束.`**

![&#x76EE;&#x524D;&#x5BF9;&#x8C61;&#x5F53;&#x6761;&#x4EF6;&#x6210;&#x7ACB;&#x65F6;&#x88AB;&#x6FC0;&#x6D3B;,](.gitbook/assets/image%20%28125%29.png)

### 顺序图中的 消息

* **面向对象方法中, `消息是对象间交互信息的主要方式.`**
  * 在任何一个软件系统中, **`对象都不是孤立存在的,`** **`它们之间通过消息进行通信`**
  * **`消息是用来说明顺序图中不同活动对象之间的通信`**. **因此,消息可以激发某个操作, 创建或撤销某个对象.**
* **结构程序设计中, `模块间传递消息的方式主要是过程(或函数)调用.`**
  * 对象A给对象B发送消息, 可以简单的理解为对象 A 调用对象B的一个操作\( operation\)
* 在顺序图中, **`消息是从一个对象的生命线指向另一个对象的生命线 的直线箭头来表示`**, **箭头上面还可以表明要发送的消息名及序号.**
  * **`顺序图中消息编号可显示,  也可不显示. 协作图中必须显示.`**
* 顺序图中, **`尽力保持消息的顺序是从左到右排列的`**. **在各对象之间, 消息的次序由它们在垂直轴上的相对位置决定.**
  * 顺序图的消息流开始于左上方, 消息2的位置比位置1低, 这意味着消息2的顺序比消息1要迟, 因为 西方的阅读习惯是从左到右.

![&#x6D88;&#x606F;&#x5728;UML&#x56FE;&#x4E2D;&#x7684;&#x8868;&#x793A;&#x548C;&#x7C7B;&#x578B;](.gitbook/assets/image%20%28107%29.png)

* **简单消息**
  * 
* **同步消息**
  * 最常见的情况是**`调用`**, **即消息发送者对象** 在它的一个操作执行时 **`调用` 接收者对象的一个操作**, 此时消息名称通常就是**`被调用的操作名称.`**
  * 当消息被处理完后, 可以返回一个**简单消息** , 或者隐含的返回. ![](.gitbook/assets/image%20%2880%29.png) 
* **异步消息**
  * 表示发送消息的对象**不用等待回应的返回消息**, 即可开始另一个活动.
  * 异步消息在某种程度上规定了**`发送方和接收方的责任`**, 即**发送方只负责将消息发送到接收方,** 至于**接收方如何响应**, `发送方则不需要知道`. **接收方来说, 在接收到消息后 它既可以对消息进行处理, 也可以什么都不做**.  

    ![](.gitbook/assets/image%20%28200%29.png)
* **反身消息**
  * 表示一个`对象可以将一个消息发送给自己,` 这就是反身消息.
  * 如果一条消息只能作为反身消息, **`那么说明该操作只能由对象自身的行为触发`**.
  * 这表明操作可以被设置为 **`private`** 属性, 只有属于同一个类的对象才能够调用它.
  * 在这种情况下, 应该对顺序图进行彻底检查, 以确定该操作不需要被其他对象直接调用. ![](.gitbook/assets/image%20%2858%29.png) 
* **返回消息**
  * 返回消息是顺序图的一个**`可选择部分`**, **它表示控制流从过程调用的一个返回.**
  * **返回消息一般可以缺省, 隐含表示每一个调用都有一个配对的调用返回.**
  * **`是否使用返回消息依赖于建模的具体/抽象程度`**. 如果需要较好的具体化, 返回消息是有用的. 否则, 主动消息就足够了.  

    ![](.gitbook/assets/image%20%2894%29.png)



### 对象的创建和撤销

* **对象的创建有两种`情况:`**
  * 顺序图中的对象的默认位置是在图的**顶部**, 如果对象在这个位置上, 那么说明在发送消息时,  **该对象就已经存在了;**
  * 如果对象是**`在执行的过程中创建的`**, 那么它的位置应该处在图的**`中间部分`**.
* **对象创建有两种`方法:`**
  * **`创建对象的消息指向对象.`**
  * **`创建对象的消息指定对象的生命线.`**

![&#x521B;&#x5EFA;&#x7684;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;, &#x6307;&#x5411;&#x5BF9;&#x8C61; &#x6216;&#x751F;&#x547D;&#x7EBF;](.gitbook/assets/image%20%28151%29.png)

* **对象的撤销有两种情况:**
  * 在处理新创建的对象, 或顺序图中的其他对象时, **`都可以发送 "destroy" 消息来撤销对象.`**
  * **`要想说明某个对象被撤销`**, 需要在**`撤销对象的生命线末端`**放一个 "**`x`**"  符号进行标识.

![1. &#x901A;&#x8FC7; destroy&#x64A4;&#x9500;, 2  &#x751F;&#x547D;&#x7EBF;&#x88AB; x &#x6807;&#x8BC6;&#x64A4;&#x9500;](.gitbook/assets/image%20%2833%29.png)

### 顺序图和用例

* **`顺序图的主要用途之一是用来为某个用例的泛化功能提供其所缺乏的解释`**, 即把用例图表达的要求转化为更进一步的精细表达.
* **`用例常常被细化为一个或多个顺序图.`**
* 顺序图除了在设计新系统方面的用途之外, **`他还能用来记录一个存在于系统的对象现在如何交互.`**

![&#x987A;&#x5E8F;&#x56FE;](.gitbook/assets/image%20%28215%29.png)

**登陆用例:**

* **用户将用户名和密码提交给 LoginAction \(控制类\)**
* **由LoginAction 调用 UserManager \(管理类\)**
* **UserManager 到用户数据库 User server 中查找用户对象并返回.**
* **由 User Manaer 判断用户名是否为空, 密码是否正确.**
* **然后将 User 对象返回**
* **返回后台主登录界面**

![&#x767B;&#x9646;&#x8FC7;&#x7A0B;&#x987A;&#x5E8F;&#x56FE;](.gitbook/assets/image%20%2870%29.png)

### 顺序图建模

* **对系统动态行为建模的过程中, 当强调按时间展开消息的传送时, 一般使用顺序图建模技术.**
* **一个单独的顺序图只能显示一个控制流.**
  * 一般情况下, 一个完整的控制流是非常复杂的, 要描述它所需要创建很多交互图\( **包括顺序图和协作图**\), 一些图是主要的, 另一些图用来描述可选择的路径可一些例外, 再用一个包对它们进行统一的管理.

### 顺序图建模参考策略

* **设置交互的语境**
  * 这些语境可以是系统, 子系统, 类 , 用例和协作的一个脚本.
* **对象从左到右**
  * 识别对象在交互语境中所扮演的角色, 根据对象的重要性及相互关系, 将其从左至右放置在顺序图的顶部.
* **设置每个对象的生命线**
  * 通常情况下, 对象存在于整个交互过程, 但它们也可以在交互过程中创建和撤销. 对于这些类对象, 在适当的时刻设置它们的生命线, 并用适当的机构型消息显示地说明它们的创建和撤销.
* **消息自上而下**
  * 从引发某个消息的信息开始, 在生命线之间画出从顶到底依次展开的消息, 显示没个消息的内容标识.
* **设置对象的激活器**
  * 可视化消息的嵌套或可视化实际计算发生时 的时间点.
* **时间和空间约束**
  * 如果需要设置时间 或空间的约束, 可以为每个消息附上合适的时间和空间约束.
* **前置和后置条件**
  * 如果需要形式化的说明某控制流, 可以为每个消息附上前置和后置条件.

### 建立顺序图的步骤

1. **确定交互范围**
2. **识别参与交互的对象和活动者;**
3. **设置对象生命线开始和结束**
4. **设置消息;**
5. **细化消息.**

![&#x5B58;&#x6B3E;&#x7528;&#x4F8B;&#x7684;&#x987A;&#x5E8F;&#x56FE;](.gitbook/assets/image%20%28100%29.png)

![&#x501F;&#x9605;&#x56FE;&#x4E66;&#x7528;&#x4F8B;&#x7684;&#x987A;&#x5E8F;&#x56FE;](.gitbook/assets/image%20%2899%29.png)



## 面向对象的设计原则

### 面向对象设计的特点

* 面向对象设计强调定义软件对象, 并且使这些软件对象相互协作来满足用户需求.
* 面向对象分析和设计的界限是模糊的,  从面向对象分析到面向对象设计是一个组件扩充模型的过程. 分析的结果通过细化直接生成设计结果, 在设计过程中逐步加深对需求的理解, 从而进一步完善需求分析的结果.
* 分析和设计活动是一个反复迭代的过程.
* 面向对象方法学在概念和表示方法上的一致性, 保证了各个开发阶段之间的平滑性.

### 面向对象设计的四个层次    \(从上到下按照时间顺序来进行\)

1. 确定系统的总体结构和风格, 构造系统的物理模型, 将系统划分成不同的子系统.
2. _**中层设计**_: 对每个用例进行设计, 规划实现用例功能的关键类, 确定类之间的关系.
3. _**进行底层设计:**_ 对每个类进行详细设计, 设计类的属性和操作, 优化类之间的关系.
4. 补充实现非功能性需求所需要的类.

### 注意点

* **面向对象设计与结构化设计的过程和方法不同, 要设计出高质量的软件系统,  `注意如下三点`:**
  * **`对接口进行设计`**
  * **`发现变化并且封装它`**
  * **`先考虑聚合然后考虑继承`**

### 强内聚

* **类内聚** -- `设计类的原则是一个类的属性和操作全部都是完成某个任务所必需的, 其中不包括无用的属性和操作.`
  * **例如**  设计一个平衡二叉树, 该类的目的就是要解决平衡二叉树的访问, 其中所有的属性和操作都与解决这个问题相关, 其他无关的属性和操作在这里都是垃圾, 应该删除.

### 弱耦合

* **在面向对象设计中, 耦合主要指不通对象之间相互关联的程度. 如果一个对象过多的的依赖于其他对象来完成自己的工作, 则不仅使该对象的可理解性下降, 而且还会增加测试, 修改的难度, 同时降低了类的可重用性和可移植性.**
* **对象不可能是完全孤立的, 当两个对象之间必须相互联系时, `应该通过累的公共接口实现耦合`,            不应该依赖于类的具体实现细节**

### 耦合方式

* **交互耦合**
  * 如果对象之间的耦合是通过消息连接来实现的, 则这种耦合就是交互耦合.  在设计时应该尽量减少对象之间发送的消息数和消息中的参数个数, 降低消息连接的复杂程度.
* **继承耦合**
  * 继承耦合是一般化类与特殊化类之间的一种关联形式, **设计时应该适当使用这种耦合**. 在设计时要特别认真分析一般化类与特殊化类之间继承关系, 如果抽象层次不合理, 可能会造成对特殊化类的修改影响到一般化类, 使得系统的稳定性降低. 另外, **`在设计时特殊化类应该尽可能多的继承和使用一般化类的属性和服务, 充分利用继承的优势.`**

### 可重用性

* **软件重用是从设计阶段开始的, 所有的设计工作都是为了使系统完成预期的任务, 为了提供工作效率, 减少错误, 降低成本, 要充分考虑软件元素的重用性.**
* **重用性有两方面的含义:**
  * 尽量使用已有的类, 包括开发环境提供的类库和已有的相似的类;
  * 如果确实需要创建新类, 则在设计这些新类时考虑将来的可重用性.
* **设计一个可重用的软件比设计一个普通软件的代价要高,  但是随着这些软件被重用次数的增加, 分摊到它的设计和实现成本就会降低.**

### 框架

* **框架是一组可用于不同应用的类的集合.  框架中的类通常是一些抽象类`并且相互有联系`, 可以通过继承的方式使用这些类.**
  * 例如 Java 应用程序接口\(API\) 就是一个成功的框架包, 为众多的应用提供服务, 但一个应用程序通常只需要其中的部分服务, **可以采用继承或聚合的方式将应用宝包与框架包关联在一起来获得需要的服务.**
* **`一般不会直接去修改框架的类, 而是通过继承或聚合 为应用创建合适的 GUI 类.`**

