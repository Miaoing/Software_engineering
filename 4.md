# 系统设计

## 软件设计的概念与设计质量

### 软件设计的定义

在 IEEE610.12-90 中 ,软件设计定义为软件 **`系统或组建的架构, 构件, 接口和其他特征`**的定义过程及该过程的结果.

![&#x8BBE;&#x8BA1;&#x5728;&#x5206;&#x6790;&#x4E4B;&#x540E;&#x8FDB;&#x884C;.](.gitbook/assets/image%20%28167%29.png)

### 软件设计

![&#x8F6F;&#x4EF6;&#x8BBE;&#x8BA1;](.gitbook/assets/image%20%2873%29.png)

### 设计工程活动

![&#x8BBE;&#x8BA1;&#x5DE5;&#x7A0B;&#x6D3B;&#x52A8;](.gitbook/assets/image%20%2828%29.png)

### 设计模型

以**`需求分析阶段`**建立的**`数据模型, 功能模型 和行为模型`** 为**输入**, **设计阶段**会建立,**`数据设计, 架构设计, 接口设计, 组件设计.`**

* 设计模型分类
  * **数据设计**
  * **结构设计**
  * **接口设计**
  * **组件设计**

### 分析模型所得到的结果与设计模型的对应关系

![&#x76F8;&#x4E92;&#x5F71;&#x54CD;, &#x4E00;&#x5BF9;&#x591A;&#x6216;&#x591A;&#x5BF9;&#x591A;&#x5173;&#x7CFB;](.gitbook/assets/image%20%2865%29.png)

### 好的设计应该具有如下三个特点

* **正确的承上**
  * 正确传递分析模型的结果.
* **正确的启下**
  * 对软件开发后续过程的进行是有帮助的. 影响应该是正面的.
* **从实现的角度给一个完整的说明**
  * 通过设计方案能够准确的预期未来的产品形态.

![&#x4E09;&#x4E2A;&#x7279;&#x70B9;](.gitbook/assets/image%20%28110%29.png)

### 设计质量属性

* **功能性**
  * 指的是软件的功能要完整.符合用户的预期.
* **易用性**
  * 指的是 软件要好用,界面对用户友好.
* **可靠性**
  * 软件不易出错. 运行稳定
* **性能**
  * 主要是指 软件的吞吐率和响应时间等等,  能运行,而且运行流畅
* **可支持性**    \(又包含三个属性\)
  * `扩展性`
    * 是指 软件添加新的功能,或升级已有功能是否方便.
  * `适应性`
    * 是指 软件适应新的环境.,新的变化,是否容易.
  * `可维护性`
    * 是指 程序代码是否易懂, 软件维护期间的成本是否更小.

### 设计指导原则

* 设计方案要把软件的全貌勾勒出来, 不能一开始就跳跃**`细节`**
* 把大框架分解为**`小模块`**, 把复杂的**`大问题,`**分解为**`小问题`**来解决
* 设计的四个方面  :  **`数据`**, **`体系结构, 接口`** 和**`组件`** .
  * 应设计出 **`系统所用的数据结构.`**  **`展现独立功能特性的各组件`**, **`各组件的与外部环境的各接口.`**
* 设计由软件需求分析过程中获得信息驱动, 采用可重复使用的方法导出
* 设计应简单易易懂, 不要追求复杂的画图技巧.

## 设计相关的八大概念

### 设计相关概念

* **抽象**
* **体系结构**
* **设计模式**
* **模块化**
* **信息隐藏**
  * 把细节信息隐藏在接口之后
* **功能独立**
* **精化**
* **重构**

#### 1. 抽象

* **含义**
  * 忽略具体的信息, 将不同事物看成相同事物的过程.
* **抽象机制** 
  * 参数化, 规范化
* **规范化抽象**
  * **数据抽象**
    * 描述数据对象的冠名数据集合.
      * 例如抽象 **门** :  `静态数据,由一系列属性参数组成` : 门的类型, 转动方向, 开门机关, 重量和尺寸等.
  * **过程抽象**
    * 具有明确和有限功能的指令序列. 
      * 例如抽象 **开 :**  `一系列动作过程 :`走到门前,伸出手并抓住把手, 转动把手拉门, 离开打开的门 .等.

#### 2. 体系结构

  

* **体系结构定义** 
  * 软件的整体结构和这种结构了系统提供概念上完整性的方式.
* **体系结构设计 可以使用大量的一种或多种建模, 从不同的角度来表达**
  * **结构模型**
  * **框架模型**
  * **动态模型**
  * **过程模型**
  * **功能模型**

#### 3. 设计模式

* **设计模式 含义**
  * 是一种可复用的方案,能够为 一类相似的问题提供一种共同的解决方案, 减少重复求解的工作量.
* **设计模式分类, 和解决的问题**
  * **实体模式**
    * 解决的问题是:   一个静态的实体如何设计? 
  * **结构模式**
    * 解决的问题是:   实体之间的结构关系如何设计? 
  * **行为模式**
    * 解决的问题是:   实体的行为如何设计?

![&#x62BD;&#x8C61;&#x5DE5;&#x5382;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;](.gitbook/assets/image%20%28166%29.png)

#### 4. 模块化

* **含义**
  * 软件被划分为命名和功能相对独立的多个组件 \(通常称为模块\), 通过这些组件的集成来满足问题的需求.
* **软件的模块性** 
  * 程序可被智能管理的单一属性.
* **模块化的理论依据**
  * 基于人类解决问题的观测数据.

![&#x6A21;&#x5757;&#x5316;&#x548C;&#x8F6F;&#x4EF6;&#x6210;&#x672C;,  &#x5C31;&#x662F;&#x8BF4;&#x6A21;&#x5757;&#x4E0D;&#x80FD;&#x592A;&#x591A;&#x4E5F;&#x4E0D;&#x80FD;&#x592A;&#x5C11;](.gitbook/assets/image%20%28130%29.png)

* **模块化设计标准**
  * `模块化的分解性` 
    * 可分解为子问题
  * `模块化的组合性`
    * 组装可重用的组件
  * `模块化的可理解性`
    * 可作为独立单元理解
  * `模块化的连续性`
    * 需求小 变化只影响单个模块
  * `模块化的保护`
    * 模块内异常只影响自身

#### 5. 信息隐藏

* **信息隐藏原则** 
  * 模块应该具有彼此相互隐藏的特性
  * 即 : 模块定义和设计时应当保证模块内的信息 \(过程和数据\) 不可以被不需要这些信息的其他模块访问
* **特点**
  * 抽象有助于定义构成软件的过程 \(或信息\)实体
  * 抽象隐藏原则定义和隐藏了模块内的过程细节和模块内的本地数据结构.

#### 6. 功能独立

* **含义**
  * 每个模块只负责需求中特定的**`子功能,`** 并且从程序结构的其他部分看, 该模块具有简单的接口.
* **优点**
  * **易于开发** : 功能被划分,  接口被简化. 易于并行
  * **易于维护\(和测试\)** : 次生影响有限,  错误传递介绍, 模块重用
* **定性衡量标准**
  * **内聚性**   : 模块的功能相对强度
  * **耦合性**   : 模块之间的相互依赖程度
  * **模块独立性强 = 高内聚低耦合**

#### 7. 精化

* **含义**
  * 逐步求精的过程
* **与抽象的关系**
  * 抽象使设计师确定过程和数据, 但不局限于底层细节.
  * 精化有助于设计者在设计过程中揭示底层细节

#### 8. 重构

* **含义**
  * 不改变组件功能 和行为条件下,  简化组件设计\(或代码\) 的一种重组技术
* **方法**
  * 检查现有**`设计的冗余情况,`  `未使用的设计元素`,  `无效或不必要的算法`, `较差的构建方式或不恰当的数据结构,`** 或任何其他可被更改从而优化设计的问题.

## 四类设计技术概要

* **数据设计**
  * 数据是软件要操作和维护的信息对象,没有了数据,那么软件的运行将没有任何意义.
* **架构设计**
  * 表明软件的总体结构, \(和房子的框架设计一样\)
* **接口设计**
  * 不同的组件之间, 一定要有适配的 插头 和插座, 而且接口连接了系统不同的组成部分,
* **组件设计 \***
  * 功能的实现主要都在组件的内部去完成

### 数据设计

* **含义**
  * 数据设计  \(有时也被称为 数据架构\), 构件高层抽象 \(客户/用户的数据视图\) 的数据模型, 信息模型
* **相关概念**
  * 数据模型
    * 数据字典, E-R图, 类图
  * 数据结构
    * 计算机存储, 组织数据的方式
  * 数据库
    * 按照数据结构来组织,  存储和管理数据的仓库
  * 数据仓库
    * 更大规模组织的数据库,能更有利于信息分析和挖掘
* **在数据阶段, 主要用到的是 `数据模型`**, **`数据结构`** **和** **`数据库`**

### 组件级别的数据设计

**设计原则**

* 应用于功能和行为系统分析的原则也适用于数据设计.
* 所有的数据结构及其对应的操作都应该确定.
* 建立数据字典并在数据定义和程序设计中应用.
* 低层次的数据设计应该推迟到设计的后期过程.
* 数据结构的表示应该直接使用数据结构中数据的模块可见.
* 开发有用的数据结构及其对应操作的程序库.
* 软件设计和编程语言应该支持抽象数据类型的实现与定义.

### 概念数据模型

![&#x6982;&#x5FF5;&#x6570;&#x636E;&#x6A21;&#x578B;, &#x5BF9;&#x5B9E;&#x4F53;&#x548C;&#x5B9E;&#x4F53;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;&#x8FDB;&#x884C;&#x4E86;&#x8BF4;&#x660E;](.gitbook/assets/image%20%28126%29.png)

### 物理数据模型

![&#x4F4E;&#x5C42;&#x7269;&#x7406;&#x6570;&#x636E;&#x6A21;&#x578B;. &#x9700;&#x8981;&#x7ED3;&#x5408;&#x5177;&#x4F53;&#x7684;&#x6570;&#x636E;&#x5E93;&#x548C;&#x6570;&#x636E;&#x7C7B;&#x578B;&#x6765;&#x8BF4;&#x660E;](.gitbook/assets/image%20%2831%29.png)

### 体系结构设计

* 系统需要执行的函数功能组件集 \(入数据库, 计算模块 \)
* 组件之间通信, 协同和合作的连接器.
* 组件集成构成系统的约束.
* 设计人员通过分析系统组成部分的已知特性, 理解其整体特性的语义模型分析.

### 风格和模式简要分类 -- 数据中心架构

![&#x6570;&#x636E;&#x4E2D;&#x5FC3;&#x67B6;&#x6784;](.gitbook/assets/image%20%28127%29.png)

* 在这个架构中, 数据存储是整个架构的中心.
* 所有的客户端软件相互之间没有交互.
* 只能通过与信息存储的交互 , 来实现信息的共享.

**数据中心架构 主要应用在 :   数据库系统,  超文本系统,  黑板系统, 在线协同文档处理 ,等等**

### 风格和模式简要分类  -- 数据流体系架构

![&#x6709;&#x7BA1;&#x9053;&#x548C;&#x8FC7;&#x6EE4;,  &#x6279;&#x5904;&#x7406;&#x5E8F;&#x5217; &#x4E24;&#x5927;&#x7C7B;](.gitbook/assets/image%20%2833%29.png)

**主要用在 : 音频处理; 图形处理;  批处理则是程序编译.**

### 风格和模式简要分类  -- **调用和返回架构**

![&#x4ECE;&#x6839;&#x8282;&#x70B9;m &#x5F00;&#x59CB;, &#x8C03;&#x7528;&#x5B50;&#x6A21;&#x5757;, &#x7136;&#x540E;&#x6700;&#x5E95;&#x5C42;&#x7684;&#x5B50;&#x6A21;&#x5757;&#x518D;&#x9010;&#x5C42;&#x5411;&#x4E0A;&#x4F20;&#x9012;](.gitbook/assets/image%20%28122%29.png)

### 风格和模式简要分类  -- **层次架构**

![](.gitbook/assets/image%20%2859%29.png)

将软件从内到外分成了很多层, 最里面是核心层, 用户的要求 最终会从内到外的实现,并从内到外的返回结果.

**主要应用就是操作系统.**

### 风格和模式简要分类  -- 面向对象架构 

![&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x67B6;&#x6784;, &#x76EE;&#x524D;&#x6700;&#x5E38;&#x7528;&#x7684;&#x67B6;&#x6784;](.gitbook/assets/image%20%2871%29.png)

* 模型   用于管理数据对象.
* 视图   用于界面的表示.
* 控制器   响应视图请求,并更新模型与视图.

### 体系结构组织与细化

* 两个基本问题
  * **控制结构**
    * 在架构内如何实现管理控制?
    * 是否有不同控制架构存在?
  * **数据传递**
    * 组件之间如何进行数据传递?
    * 数据流是否连续, 或者传递给系统的数据对象是否零散?

### 部署设计

**需要全盘考虑先前设计方案, 与 QoS需求, 平衡取舍相关问题的成本,以实现最佳解决方案.**

**提前考虑软件的部署, 也有助于提早发现环境对软件带来的约束, 从而从设计阶段考虑相应的解决办法.**

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;](.gitbook/assets/image%20%28155%29.png)

### 部署设计输出

输出包含 **`部署架构, 实现规范, 实施计划`**  三大部分.

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;&#x8F93;&#x51FA;](.gitbook/assets/image%20%28129%29.png)

### 部署设计方法

![&#x90E8;&#x7F72;&#x8BBE;&#x8BA1;&#x65B9;&#x6CD5;](.gitbook/assets/image%20%2849%29.png)

### 接口设计  \(含界面设计\)

* **接口设计主要包含  内部接口的设计 和 外部接口的设计 两个方面.**
  * **内部接口的设计**  主要是指内部模块之间进行通信的接口设计,一般会作为架构设计 或组件设计的一部分  同时进行.
  * **外部接口的设计**  包括人机接口以及系统与外部系统的接口.
* **界面设计 \(GUI\)  高效用户界面设计有三条重要原则:**
  * 允许用户操纵控制 \(用户为中心\)
  * 减少用户记忆负担
  * 保持界面一致
* **环境分析 确定了用户接口操纵的物理结构和社会结构.**

### 组件设计\*

* **面向过程的组件设计**
  * 函数与模块的设计内容
* **面向对象的组件设计**
  * 类与操作的设计内容

## 面向过程的总体设计

### 结构化的总体设计方法

* 首先研究, 分析 和审查 数据流图.  从软件的需求规格说明中弄清数据加工的过程, 对于发现的问题及时解决.
* 然后根据数据流图决定问题的类型.  数据处理问题典型的类型有两种:  变换型和事物型. 针对两种不同的类型分别进行分析处理.
* 由数据流图导出系统的初始化结构图.  **这个系统结构图是最重要的部分**
* 利用一些启发式原则来改进系统的初始化结构图, 知道得到符合要求的结构图为止
* 修改和补充数据词典.

### 在系统结构图中的模块

* **传入模块**
  * 它从**`下属模块`**取得数据,  经过某些数据, 再将其传送给**`上级模块`**.  **他传送的数据流叫做`逻辑输入数据流`.**
* **传出模块**
  * 它从**`上级模块`**取得数据, 进行某些处理, 再将其传送给**`下属模块`**.  **他传送的数据流叫做`逻辑输出数据流`.**
* **变换模块**
  * 它从**`上级模块`**取得数据, 进行特定的处理, 转换成其他形式, 在传送回**`上级模块`**. 它加工的数据流叫做**`变换数据流.   (数据从哪里来,就返回哪里去)`**
* **协调模块**
  * 对所有**`下属模块`**进行协调和管理的模块.

![&#x4F20;&#x5165;&#x6A21;&#x5757;, &#x4F20;&#x51FA;&#x6A21;&#x5757;, &#x53D8;&#x6362;&#x6A21;&#x5757;, &#x534F;&#x8C03;&#x6A21;&#x5757;](.gitbook/assets/image%20%2896%29.png)

### 变换型系统结构图

* 变换型数据处理问题的工作大致分为**三步**,即  **`取得数据, 交换数据 和 给出数据`**.
* 相应于 **`取得数据, 变换数据, 给出数据`** , **变换型系统构造图由`输入, 中心变换 和 输出`**等三部分组成.

![&#x53D8;&#x6362;&#x6027;&#x4F53;&#x7CFB;&#x7ED3;&#x6784;&#x56FE;](.gitbook/assets/image%20%2882%29.png)

### 事务性系统结构图

* 它接受一项书屋, 根据事务处理的特点和性质, 选择分派一个适当的处理单元, 然后给出结果.
* 在事物型系统结构图中, **`事务中心模块`** 按所接受的事物的类型,  选择某一事务处理模块执行. 各事**`务处理模块`** 并列. 每个事务处理模块可能要调用若干个**`操作模块`**, 而操作模块又可能调用若干个**`细节模块.`**

![&#x4E8B;&#x52A1;&#x6027;&#x7CFB;&#x7EDF;&#x7ED3;&#x6784;&#x56FE;](.gitbook/assets/image%20%28135%29.png)

### 变换型 与 事务性 分析

#### 变换性分析

* 是从数据流图推倒出变换型 体系结构 的过程
  * **第一步是** **`重画数据流图`**
  * **第二步是** **`区分有效(逻辑) 输入, 有效(逻辑) 输出 和中心变换部分`**
  * **第三步是 进行一级分解, 设计上层模块**
  * **第四步是 `进行二级分解, 设计输入, 输出 和 中心变换部分的中, 下层模块.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41;&#x56FE;, &#x4E0B;&#x9762;&#x662F;&#x6839;&#x636E;&#x6570;&#x636E;&#x6D41;&#x56FE;&#x91CD;&#x753B;&#x7684;&#x53D8;&#x6362;&#x578B;&#x6570;&#x636E;&#x6D41;&#x56FE;](.gitbook/assets/image%20%28157%29.png)

#### 变换分析注意事项

* **深度遍历模块设计**
  * 在选择模块设计的次序时,必须对一个模块的全部直接下属模块都设计完成之后, 才能转向另一个模块的下层模块的设计.
* **耦合与内聚**
  * 在设计下层模块时, 应考虑模块的耦合和内聚问题, 以提高初始结构图的质量.
* **使用 "黑箱"  技术**
  * 在设计当前模块时, 先把这个模块的所有下层模块定义成 "黑箱", 在设计中利用它们时, 暂时不考虑其内部结构和实现. 在这一步定义好的 "黑箱" , 在下一步就可以对他们进行设计和加工. 这样, 又导致更多的 "黑箱". 最后, 全部 "黑箱" 的内容结构应完全被确定.
* **控制直接下属的模块数**
  * 在模块划分时, 一个模块的直接下属模块一般在5个左右. 如果下属模块超过10个, 可设立中间层次.
* **停止模块功能分解的情况**
  * 模块不能再分析称为明显的子任务.
  * 分解成用户提供的模块或程序库的子程序;
  * 模块的界面是输出 /  输出设备传送的信息;
  * 模块不易再分解得过小.



#### 事务性分析

* 在很多软件应用中, 存在某种软件数据流, 他可以引发一个或多个处理, 这些处理能够完成该作业要求的功能. 这种**数据流**就叫做**`事务`.  \(可以把一个界面的主控台 看成是事务的中心\)**
* 和变换分析一样, 事务分析也是从分析数据流图开始**`, 自顶向下, 逐步分解, 建立系统结构图.`**

![&#x4E0A;&#x9762;&#x662F;&#x6570;&#x636E;&#x6D41; , &#x4E0B;&#x9762;&#x662F;&#x4E8B;&#x52A1;&#x5206;&#x6790;&#x540E;&#x7684;&#x6570;&#x636E;&#x6D41;,  4 5  6 &#x7684;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4F1A;&#x8FD4;&#x56DE;&#x7ED9;&#x4E3B;&#x63A7;, &#x7136;&#x540E;&#x518D;&#x7531;&#x4E3B;&#x63A7;&#x8F93;&#x51FA;](.gitbook/assets/image%20%28158%29.png)

#### 事务型分析过程

该过程自顶向下 依次执行

* **识别事务源**
  * 利用数据流图和数据字典, 从问题定义和需求分析的结果中, 找出各种需要处理的事务, 通常, 事务来自物理输入装置. 有时, 设计人员还必须区别 **`系统的输入, 中心加工 和 输出`**中产生的事务.
* **规定适当的事务性结构**
  * 在确定了该数据流图具有事务性特征之后, 根据模块划分理论, 建立适当的事务性结构.
* **识别各种事务和他们定义的操作**
  * 从问题定义和需求分析中找出的**`事务及其操作必须的全部信息,`** 对于系统内部产生的事务, **必须仔细的定义他们的操作.**
* **注意利用公共模块**
  * 在事务分析的过程中, 如果不同事务的一些中间模块可由具有类似的语法和语义的若干个底层模块组成, 则可以把这些底层模块构造成`公共模块.`
* **事务处理模块**
  * 对每一事务, 或对联系密切的一组事务, **`建立一个事务处理模块`**; 如果发现在系统中有类似的事务, 可以把他们**`组成一个事务处理模块`**.
* **操作模块**
  * 对事务处理模块规定 他们全部的下层**`操作模块.`**
* **细节模块**
  * 对操作模块规定 他们的全部**`细节模块`**.

![&#x4E8B;&#x52A1;&#x578B;&#x5206;&#x6790;&#x8FC7;&#x7A0B;](.gitbook/assets/image%20%2899%29.png)

### 混合结构分析

* **变换分析是软件系统结构设计的主要方法.**
  * 一般一个大型的软件系统是**`变换型结构`**和**`事务性结构`**和**`混合结构.`**
* **所以, 我们通常利用以 `变换分析为主, 事务分析为辅` 的方式进行软件结构设计.**

![&#x6DF7;&#x5408;&#x6A21;&#x578B;&#x7684;&#x6848;&#x4F8B;, &#x4E8B;&#x52A1;&#x6027;&#x548C;&#x53D8;&#x6362;&#x578B;](.gitbook/assets/image%20%2834%29.png)

### 面向过程的组件设计之 流程图

































