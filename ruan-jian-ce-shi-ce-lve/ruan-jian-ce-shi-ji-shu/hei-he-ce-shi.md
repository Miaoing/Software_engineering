# 黑盒测试

## 黑盒测试

* 测试对象看做一个黑盒子, 测试人员完全不考虑内部的逻辑结构和内部特性.
* 只依据程序的需求规格说明书, 检查程序的功能是否符合它的功能说明.
* 又叫做功能测试或数据驱动测试.

### 检查范围

* 是否有不正确或遗漏了的功能?
* 在接口上, 输入能否正确的接受? 能否输出正确的结果?
* 是否由数据结构出错 或 外部信息访问错误?
* 性能上是否能够满足要求?
* 是否有初始化或终止性错误?

**完全测试的困难性 :** 如果考虑所有可能的输入条件和输出条件中, 黑盒测试同样可能是天文数字.

![&#x4E0D;&#x8981;&#x4F7F;&#x7528;&#x7A77;&#x4E3E;&#x7684;&#x65B9;&#x6CD5;](../../.gitbook/assets/image%20%28223%29.png)

### 等价类

**等价类:**  某个输入域的子集合.  在该子集合中, 各个输入数据对于揭露程序中的错误都是等效的.

* **有效等价类**
  * 对于程序规格说明来说, 是合理的, 有意义的输入数据构成的集合.
* **无效等价类**
  * 对于程序的规格说明来说, 是不合理的, 无意义的输入数据结构的集合.

**在设计等价类的时候  要同时考虑 `有效等价类`和`无效等价类` 两种.**

### 等价类划分

* **基本思想**
  * 把所有可能的输入数据, 即程序的输入域划分成若干部分, 然后从每一部分中选取少数有代表性的数据作为测试用例.
* **测试步骤**
  * 划分等价类
  * 选取测试用例
* **原则**
  * **\(1\)  如果输入条件规定了取值范围, 或值的个数, 则可以确立`一个有效等价类` 和 `两个无效等价类`.**  
  * **\(2\) 如果输入条件确定了输入值的集合,  或者规定了 "`必须如何`" 的条件, 这是可确立`一个有效等价`类和`一个无效等价类`.**
  * **\(3\)  如果输入条件是一个布尔量, 则可以确定`一个有效等价类` 和`一个无效等价类`.**
  * **\(4\)  如果规定了输入数值的一组值, 而且要对每个输入值分别进行处理. `可为每一个输入值确立一个有效等价类`, 所有不 运行的输入值集合为`一个无效类.`**
  * **\(5\)  如果规定了输入数据必须遵守的规则,  则可以确立一个有效等价类 \(符合规则\)  和若干个无效等价类 \(从不同角度违反规则\).**

![&#x539F;&#x5219;1](../../.gitbook/assets/image%20%28284%29.png)

![&#x539F;&#x5219;2](../../.gitbook/assets/image%20%2871%29.png)

![&#x539F;&#x5219;3](../../.gitbook/assets/image%20%2862%29.png)

![&#x539F;&#x5219;4](../../.gitbook/assets/image%20%28197%29.png)

![&#x539F;&#x5219;5](../../.gitbook/assets/image%20%28117%29.png)

#### 等价类划分步骤

1. 确定等价类
2. 建立等价类表, 列出所有划分出的等价类.
3. 为每个等价类规定一个唯一编号.
4. 设计一个新的测试用例, 尽可能多的覆盖尚未被覆盖的有效等价类, 重复这一步, 直到所有有效等价类都被覆盖为止.
5. 设计一个新的测试用例, 仅覆盖一个尚未被覆盖的无效等价类, 重复这一步, 知道所有的无效等价类都被覆盖位为止.

**对于有效等价类是`一个测试尽量多的覆盖多个有效等价类`, 而`无效等价类, 一个测试只覆盖一个`.**

![&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;](../../.gitbook/assets/image%20%28133%29.png)

![&#x4F8B;&#x5B50;&#x7684;&#x89E3; 1](../../.gitbook/assets/image%20%2816%29.png)

![&#x4F8B;&#x5B50;&#x7684;&#x89E3; 2](../../.gitbook/assets/image%20%28228%29.png)

![&#x4F8B;&#x5B50;&#x7684;&#x89E3;3 , &#x53EA;&#x7ED9;&#x51FA;7&#x4E2A;&#x89E3;](../../.gitbook/assets/image%20%2890%29.png)



## 边界值分析

* **含义**
  * 黑盒测试方法
  * 等价类划分方法的补充
* **方法**
  * 确定边界情况
  * 选取整合等级, 刚刚大于, 或刚刚小于边界的值作为测试数据.
* **原因**
  * 大量的错误是发生在输入或输出范围边界上.
  * 边界测试可以查出更多的错误.
* **边界指标**
  * 相当于输入, 输出等价类而言, 稍高, 低于其边界值的一些特定情况.

![&#x4E00;&#x4E2A;&#x4E09;&#x89D2;&#x5F62;&#x7684;&#x4F8B;&#x5B50;](../../.gitbook/assets/image%20%28191%29.png)

![&#x8FB9;&#x754C;&#x8868;](../../.gitbook/assets/image%20%28236%29.png)



## 状态测试  **和 软件状态**

* **状态测试**
  * 在黑盒测试阶段, 通过对状态的测试间接的加以验证功能.
* **软件状态**
  * 软件当前所处的条件或者模式. 
  * 除了极少数简单程序外, 均需选择**重要的内容**进行测试.

**建立转换图   --&gt;  根据转换图设计测试用例  用于测试.**

\*\*\*\*

### 建立转换图

* **建立过程转换图**
  * 找出从一种状态转入另一种状态所需的输入和条件.
  * 标识出软件可能进入的每一种独立状态.
  * 找出进入或退出某种状态时的设计条件及输出结果.

![&#x4E00;&#x79CD;qq&#x7684;&#x793A;&#x4F8B;](../../.gitbook/assets/image%20%2821%29.png)

![](../../.gitbook/assets/image%20%2892%29.png)

### **根据状态转换图设计测试用例**

* **原则**
  * 每种状态至少访问一次.
  * 测试看起来是最常见和最普遍的状态转换.
  * 测试状态之间最不常用的分支.
  * 测试所有错误状态及其返回值.
  * 测试状态的随机转换.

![&#x6839;&#x636E;&#x8F6C;&#x6362;&#x56FE;&#x5EFA;&#x7ACB;&#x7684;&#x6D4B;&#x8BD5;&#x7528;&#x4F8B;](../../.gitbook/assets/image%20%28118%29.png)

## 静态分析方法

* **含义**
  * 不允许程序, 通过检查和阅读等手段来发现错误并评估代码质量的测试技术.
* **作用**
  * 代码标准, 质量监控提高可靠性
  * 尽早通过源代码检查发现缺陷
  * 代码审核定位易产生错误的模块.
* **适用**
  * 非常有效的质量保证手段
  * 越来越多的被采用.

### 通用评审过程

1. **计划**
2. **概述**
3. **准备**
4. **评审会议**
5. **返工**
6. **追踪**

### 静态分析的主要内容

**静态分析应该在需求的时候就开始进行**

![&#x9759;&#x6001;&#x5206;&#x6790;&#x7684;&#x4E3B;&#x8981;&#x5185;&#x5BB9;](../../.gitbook/assets/image%20%28164%29.png)

### 静态分析方法

* **同事审查**
  * 适用于初次审查, 要求最低的正式方法,  也成为伙伴审查.
* **走查**
  * 开发组内部进行.
* **审查**
  * 以会议形式,  由开发组, 测试组 和 相关人员 联合进行.



