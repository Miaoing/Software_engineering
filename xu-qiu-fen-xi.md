# 废弃-----------需求分析

## 需求分析的任务



* **基本任务:**
  * 准确的回答 "系统必须做什么?"
* **借助于`当前系统的逻辑模型`导出`目标系统的逻辑模型`,解决目标系统的"`做什么`"的问题.**

![&#x7CFB;&#x7EDF;&#x903B;&#x8F91;&#x6A21;&#x578B;&#x5230;&#x76EE;&#x6807;&#x7CFB;&#x7EDF;&#x903B;&#x8F91;&#x6A21;&#x578B;](.gitbook/assets/image%20%28242%29.png)

###    需求工程中存在的困难

* **误解;**
* **完整性问题; \(完整的获取用户需求, 完整的叙述问题\)**
* **需求不稳定;**
* **用户意见不统一;**
* **错误的要求;**
* **认识的混淆;**

### 获取需求得两条原则

* **第一 ,  只有当你彻底弄懂了用户的`全部意图之后`, 才有可能建立起`成功的软件系统;`**
* **第二,  一切从用户角度着想, 在条件\( 人力,物理,财力和技术力量等\)  允许的情况下尽可能保证用户从所构造的软件系统中获得最大利益;**

### **需求分析的过程**

* **确定对系统的综合需求:**
  * **`1.系统功能要求,   2.系统性能要求,   3.运行要求,   4.将来可能提出的要求.`**
* **分析系统的数据要求;**
* **导出系统的逻辑模型:**
  * **`数据流程图,  数据字典,  主要算法`**
* **修正系统开发计划;**
* **开发原型系统;**

## 需求分析的过程

### **问题识别**

**从系统的角度来理解软件并评审软件范围是否恰当.**

* **确定对目标系统的综合要求, 即软件的需求;**
* **提出这些需求实现条件, 以及需求应达标的标准;**
* **建立分析所需要的通信途径;**

### 软件需求包括内容

*  **软件的需求包括:**
  * **`功能需求;`**
  * **`性能需求;`**
  * **`环境需求;`**
  * **`可靠性需求;`**
  * **`安全保密要求;`**
  * **`用户界面需求;`**
  * **`资源使用需求;`**
  * **`成本消耗需求;`**
  * **`开发进度需求;`**
  * **`预先估计以后系统可能达到的目标;`**
* **建立分析所需要的通信途径, 以保证能顺利的对问题进行分析.**

![&#x7528;&#x6237;,&#x5206;&#x6790;,&#x7BA1;&#x7406;,&#x5F00;&#x53D1;  &#x5404;&#x4E2A;&#x4EBA;&#x5458;&#x95F4;&#x7684;&#x5173;&#x7CFB;](.gitbook/assets/image%20%28240%29.png)

### 分析与综合

 **从`信息流` 和`信息机构`出发,  `逐步细化所有的软件功能`,  找出`系统各元素之间的联系, 接口特性和设计上的约束`,  分析它们是否满足功能要求, 是否合理.  剔除其不合理的部分, 增加其需要部分. 最终 总合成系统的解决方案,  给出** 目标系统的详细逻辑模型.

### **常用的分析方法**

* **面向数据流的 `结构化分析方法(SA);`**
* **面向数据结构的** **`Jackson方法(JSD);`**
* **面向对象的`分析方法(OOA)等;`**

### 编制需求分析阶段的文档

* **软件需求说明书;**
* **数据需求说明书;**
* **初步的用户手册;**
* **修改, 完善与确定软件开发实施计划.**

###  **需求分析评审**

* **系统定义的目标是否与用户的要求一致;**
* **系统需求分析阶段提供的文档资料是否齐全;**
* **文档中的所有描述是否 完整, 清晰, 准确 的反映用户的要求;**
* **与所有其他系统成分的重要接口是否都已经描述 ;**
* **被开发项目的数据流与数据结构是否足够, 确定;**
* **所有图标是否清楚,  在不补充说明时 能否理解;**
* **主要功能是否已包括在规定的软件范围之内, 是否都已充分说明.**
* **设计的约束条件或限制条件是否符合实际;**
* **开发的技术风险是什么;**
* **是否考虑过软件需求的其他方案;**
* **是否考虑过将来可能提出的软件需求;**
* **是否详细指定了检验标准, 他=它们能否对系统定义成是否成功进行确认;**
* **有没有遗留, 重复 或 不一致的地方;**
* **用户是否伸长了初步的用户手册;**
* **软件开发计划中的估算是否受到了影响;**

### 需求分析的具体流程

![&#x9700;&#x6C42;&#x5206;&#x6790;&#x6D41;&#x7A0B;](.gitbook/assets/image%20%28138%29.png)

## 软件需求分析的原则

### 软件需求分析方法的共同原则

* **需要能够表达和理解问题的`信息域和功能域.`**
* **要能以层次化的方式对问题进行`分解和不断细化(自顶向下逐层分解);`**
* **要给出系统的`逻辑视图` 和`物理视图;`**

## 结构化分析方法\(SA\)   \(重点\)

**`数据流图必须和数据词典一起使用, 否则会出现二义性;`**

* **具体来说,  结构化分析方法就是用 `抽象模型` 的概念, 按照软件内部 `数据传递, 变换` 的关系, `自顶向下逐层分解`, 知道找到满足功能要求的可实现的软件为止;**
* **采用面向数据流进行需求分析的方法;**
* **结构化分析方法适合于数据处理类型软件的需求分析.**

### 结构化分析方法使用工具

* **`数据流图;`**
* **`数据词典;`**
* **`结构化语言;`**
* **`判定表与判定树.`**

### 数据流图 \(DFD\)

**数据流图从 `数据传递`和`加工的角度,` 以图形的方式刻画`数据流`从输入到输出`移动变换`过程.**

* 数据流图中的主要图形元素:
  * 数据加工\(数据变换\) ;  ![](.gitbook/assets/usdsi-pvoydqrs-phv-l5-jtt.png) 
  * 数据源点 或 终点\(外部实体\);  ![](.gitbook/assets/d8hsm-zc-gtip-n-yqbr9hv.png) 
  * 数据流;    ![](.gitbook/assets/wb-6usd4uf-rnusdllfjo1b-qwv.png)
  * 数据存储文件;   ![](.gitbook/assets/27x9-16b-of_x-t-fa323c.png) 

### 数据流与数据加工之间的关系

![&#x6570;&#x636E;&#x6D41;&#x4E0E;&#x6570;&#x636E;&#x52A0;&#x5DE5;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;](.gitbook/assets/image%20%2866%29.png)

![](.gitbook/assets/image%20%28255%29.png)

![&#x9010;&#x5C42;&#x5206;&#x6790;&#x65B9;&#x6CD5;](.gitbook/assets/image%20%28272%29.png)

### 数据流图绘制步骤

#### 例1: 对商店业务处理系统:

* **首先确定系统的输入和输出.**
  * **根据商店业务画出顶层数据流图, 以反映`最主要`业务处理流程.**

#### 高层逻辑模型图

![&#x4F8B;1, &#x9AD8;&#x5C42;&#x903B;&#x8F91;&#x6A21;&#x578B;, &#x5BF9;&#x4E8E;&#x5F00;&#x53D1;&#x4E0D;&#x591F;&#x6E05;&#x6670;](.gitbook/assets/image%20%2869%29.png)

* 经过分析, 商店业务处理的**主要功能** 应当有**`销售, 采购, 会计`** 三大项.  **主要数据流输入的源点**和**输出终点**是**顾客**和**`供应商`**.
* 然后从输入端开始, 根据商店业务工作流程, 画出数据流  流经的各加工框, 逐步画到输出端,  得到第一层数据加工流图.

#### 第一层数据流图

![&#x7B2C;&#x4E00;&#x5C42;&#x6570;&#x636E;&#x6D41;&#x56FE;](.gitbook/assets/image%20%283%29.png)

* **细化每一个加工框** - **`销售细化`**

![&#x9500;&#x552E;&#x7EC6;&#x5316;](.gitbook/assets/image%20%28226%29.png)

* **细化每一个加工框 - `采购细化`**

![&#x91C7;&#x8D2D;&#x7EC6;&#x5316;](.gitbook/assets/image%20%28148%29.png)

### 检查和修改数据流图

* **数据流图上所有图形符号 `只限于 前述的四种基本图形元素;`**
* **`数据流图的主图必须包括前述四种基本元素, 缺一不可;`**
* **`数据流图的主图上的数据流必须封闭在外部实体之间;(输入输出,或源点)`**
* **每个加工`至少有一个输入数据流和一个输出数据流;`**
* **在数据流图中, 需`按层给加工框编号`,  编号表名改加工所处层次以及上下层的亲子关系;**
* **规定任何一个数据流子图 必须 与他上一层的一个加工`对应,` 两者的输入数据流和输出数据流必须一致.  `此即父图与子图的平衡;`**
* **可以在数据流图中加入物质流,  帮助用户理解数据流图;**
* **图上每个元素都必须有名字;**
* **数据流图中 `不可夹带控制流;`**
* **初画时可以忽略琐碎的细节,  `以集中精力与主要数据流`.**

\*\*\*\*

## 数据词典  \(DD\)

* **`数据字典`是关于`数据的信息集合`,  也就是对数据流图中包含的所有元素的定义的集合.**
* **`数据字典的任务是对数据流图中出现的所有被命名的图形元素的名字都有一个确切的解释;`**
* **`数据词典与数据流图配合`, 能清楚地表达数据处理的要求.**

### **数据字典的内容 -- 词条说明**

*  ****对于在数据流图中每一个被命名的图形元素, 均加以定义, 其内容有: **`名字, 别名或编号, 分类, 描述, 定义, 位置, 其他, 等...`**

#### \(1\) 数据流词条描述

* **数据流名:** 
* **说明:  `简要介绍作用即它产生的原因和结果;`**
* **数据流来源:  `来自何方;`**
* **数据流去向:  `去向何处;`**
* **数据流组成:  `数据结构`;**
* **数据量他那流通量:  `数据量, 流通量`.**

#### \(2\) 数据元素词条描述

* **数据元素名**
* **类型:  `数字(离散值, 连续值), 文字(编码类型);`**
* **长度;**
* **取值范围;**
* **相关的数据元素及数据结构.**

**\(3\) 数据文件词条描述**

* **数据文件名;**
* **简述:  `存放的是什么数据;`**
* **输入数据;**
* **输出数据;**
* **数据文件组成: `数据结构;`**
* **存储方式:  `顺序, 直接,  关键码;`**
* **存储频率.**

#### \(4\)  加工逻辑词条描述

* **加工名;**
* **加工编号:  `反应该加工的层次;`**
* **简要描述:  `加工逻辑及功能简述;`**
* **输入数据流;**
* **输出数据流;**
* **加工逻辑:  `简述加工程序, 加工顺序`.**

#### \(5\) 源点及 汇\(终\) 点 词条描述

* **名称: `源点及汇(终) 点名;`**
* **简要描述 :  `什么类型的源点 及 汇(终)点;`**
* **有关数据流;**
* **数目: ...**

### **数据字典的内容 -- 数据词典 数据结构 的描述**

![&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x63CF;&#x8FF0;](.gitbook/assets/image%20%28204%29.png)

![&#x4E00;&#x4E2A;&#x63CF;&#x8FF0;&#x6848;&#x4F8B;](.gitbook/assets/image%20%28136%29.png)

![&#x7EED;&#x8868;](.gitbook/assets/image%20%2825%29.png)

### **数据字典的内容 --  基本加工逻辑说明**

* **对数据流图的每一个基本加工, 必须有一个基本加工逻辑说明;**
* **基本加工逻辑说明 必须描述基本加工   `如何把数据数据流变换成输出数据流的加工规则(算法);`**
* **加工逻辑说明必须描述`加工的策略`而不是实现加工的细节;**
* **加工逻辑说明中包含的信息应该是充足的,  完备的,  有用的,  无冗余的.** 

### **数据字典的内容 -- 用于加工逻辑说明的工具**

* **结构化语言;**
* **判定表;**
* **判定树;**
* **层次方框图;**
* **Warnier图;**
* **IPO图 \(输入,处理,输出\).**

#### \(1\) 结构化语言

* **语言命令动词;**
* **数据字典中定义的名字;**
* **有限的自定义词;**
* **逻辑关系词 `IF_THEN_ELSE,  CASE_OF,  WHILE_DO,  REPEAT_UNTIL 等组成.`**

**`结构化语言`是 一种介于自然语言和形式化语言之间的语言;**

**语言的`正文用基本控制结构进行分割`, 加工中的`操作用自然语言短语来表示;`**

**其基本控制结构有三种:**

1. **简单陈述句结构:  避免复合语句;**
2. **重复结构: while\_do 或  repeat\_until 结构.**
3. **判定结构:  if\_then\_else 或  case\_of 结构;**

![&#x7ED3;&#x6784;&#x5316;&#x8BED;&#x8A00;&#x793A;&#x4F8B;](.gitbook/assets/image%20%28104%29.png)

#### \(2\)判定表

**如果输出流图的加工需要依赖于`多个逻辑条件的取值`, 需要判定表来描述比较合适.**

![&#x6761;&#x4EF6;&#x548C;&#x52A8;&#x4F5C;&#x7684;&#x89C4;&#x5219; &#x4EE5;&#x53CA;&#x5173;&#x7CFB;](.gitbook/assets/image%20%284%29.png)

![&#x793A;&#x4F8B;](.gitbook/assets/image%20%28215%29.png)

#### \(3\)判定树

**判定树也是用来表达加工逻辑的一种工具.**  有时候他比判断表更直接;

![&#x4F7F;&#x7528;&#x524D;&#x9762;&#x7684;&#x53D1;&#x8D27;&#x5355;,&#x53EF;&#x4EE5;&#x8F6C;&#x6362;&#x6210;&#x8FD9;&#x79CD;&#x5224;&#x5B9A;&#x6811;](.gitbook/assets/image%20%2831%29.png)

#### \(4\) 层次方框图

* **层次方框图 `用树型结构的一系列多层次的矩形框 描绘数据的层次结构;`**
* **树形结构的顶层 `是一个单独的矩形柜,` 他表达`完整的数据结构`, 下面的各层矩形框代表这个`数据的子集`, 最底层的各个框代表组成这个数据的`实际数据元素`  \( 不能再分解的元素 \) .**

![&#x5C31;&#x662F;&#x6811;&#x5F62;&#x7ED3;&#x6784;,&#x4ECE;&#x4E0A;&#x5C42;&#x5230;&#x5E95;&#x5C42;](.gitbook/assets/image%20%2861%29.png)

#### \(5\) Warnier图

**Warnier 图也用树形结构描绘信息,  且更丰富, 能表达逻辑关系.**

![&#x793A;&#x4F8B;](.gitbook/assets/image%20%28230%29.png)

#### \(6\)IPO 图 \(输出,处理,输出\)

* **IPO图是 输出/处理/输入 图的简称, 能苟方便地描述`输入数据`, 对数据的`处理和输出数据`之间的关系.**
* **基本形式**  
  * **`在左边的框中列出有关的输入数据, 在中间的框内列出主要的处理, 在右边的框内列出产生的输出数据.`**

![&#x6587;&#x4EF6;&#x66F4;&#x65B0;&#x7684;IPO&#x56FE;](.gitbook/assets/image%20%2810%29.png)

## 数据及数据库需求

### 概述

* **在软件系统中需要处理的数据是现实世界中存在的事物 及其 联系的反应;**
* **人们通常将与数据处理有关的领域分为三个世界**
  * **`现实世界;`**
  * **`信息世界;`**
  * **`数据世界.`**

#### 现实世界

* **`现实世界` 是存在于人们头脑之外的客观世界,  现实世界中的事物可分成`对象`和`性质`两类.**
* **`对象`可以是人, 是物, 还可以是实际的东西 或概念的东西, 例如, 大学,城市等.  对象还可以指事物与事物间的联系;**
* **`性质` 则是指事物的性质或特征;**

#### 信息世界

* **`信息世界`也叫做观念世界,  是现实世界在人们头脑中的反应;**
* **`客观世界中的事物在信息世界中叫做 实体,  反应事物之间联系的叫做 实体模型;`**
* **`实体是由若干属性的属性值组成.  属性`是实体某一方面的特征, 相应于事物的性质.** 
  * **例如一个学生实体是如下的一个5元组:**
    * \(021149, 郑枫, 女, 19, 计算机应用\)
      * **5元组中的每一元素是学生的某一属性的属性值. 他们对应的属性集合是 : `(学好, 姓名, 性别, 年龄, 专业) ;`**
      * **这些属性集合表征了 "学生" 实体的类型,  叫做 `实体型,`  同一类型的实体的集合叫做`实体集`;**
      * **`数据世界` 则是信息世界中信息的`数据化`, 现实世界中的事物及其联系在数据世界中用`数据模型描述`.**
      * **`描述每一实体的数据称为  记录, 描述属性的数据叫做 数据项 或 字段;`**
      * **与实体集相对应的称为`文件.`**
        * 例如,  学生文件就由多个记录组成, 这些记录放在一起构成一个二维表. 表中每一横排叫做一个记录或元组, 每一纵列叫做一个属性.

![&#x5B66;&#x751F;&#x8868;](.gitbook/assets/image%20%28135%29.png)

* **`记录`**由 **`数据项`** 组成, 正如实体由若干属性的属性值组成一样;
* 一般数据项沿用属性名. 用做属性名时表示观念信息, 用作数据项名时表示数据信息. 每个数据项包括两个特征:  `数据类型和数据长度;`
* **若干同类型的记录构成`文件.`**
* 为了对文件中的记录有效组成的存取,  通常指定一个数据项进行区别, 有个数据项叫做关键字.

### E-R 方法 \(Entity - Relationship  Approach\) 和实体模型

* **在需求分析阶段进行数据库逻辑设计过程中,  `使用 E-R 图, 可定义一个实体模型.`**
* **`实体模型是现实世界的纯表示,`  它`不涉及数据世界的 数据结构, 存储路径, 存取效率等`问题,  因此 , `它可以转换成数据库中的数据模型.`**

#### E-R 图中表示实体联系的符号如下: 

* **`方框`表示`实体型`或`属性;`**
* **`连线`** 表示 **`实体之间,`** 或**`实体与属性之间的联系;`**
* **`连线上的短竖线可以看成是 "1" , 而圆圈隐含表示 "0" .`**

![E-R &#x65B9;&#x6CD5;&#x548C;&#x5B9E;&#x4F53;&#x6A21;&#x578B;&#x7B26;&#x53F7;](.gitbook/assets/image%20%2840%29.png)

![&#x4F8B;&#x5B50;](.gitbook/assets/image%20%28128%29.png)

### 数据结构的规范化

* 信息域分析需要确定**`数据的内容,`** 每个数据项要用表格列出,  最后组织成文件的逻辑结构,  即面向应用而不是面向存储的结构;
* 为了便于数据库的设计,  常常要对这种结构做一些简化, 其中最常见的一种方法就是规范化技术.
* "**规范化"** 将 **数据的逻辑结构** 归纳为满足一定条件的**`二维表`**\(关系\).
  * **表格中每个信息项必须是一个不可分割的数据项, 不可使组项;**
  * **表格中每一列 \(列表示属性\) 中所有信息项必须是同一类型, 各列的名字\(属性名\) 互异, 列的次序任意;**
  * **表格中各行 \(行表示元组\) 互不相同,  行的次序任意;**
* **不满足上述要求的二维表或关系,  叫做非规范化关系.  对于非规范化的关系, 必须将它规范化, 即利用更单纯,更规则的关系来替代原来的关系.**

#### 规范化的目的

* **`消除数据冗余,` 即消除表格中数据的重复.**
* **`消除多义性`, 使关系中的属性含义清楚, 单一 ;**
* **`使关系的"概念"单一化,` 每个数据项只是一个简单的数 或字符串, 而不是一组项或重复组;**
* **`方便操作`, 使数据的插入, 删除与修改操作可行, 方便;**
* **`使关系模式更灵活,` 易于实现接近自然语言的查询方式.**

### 数据库的规范化要求:

* **第一范式**
  * **`每个属性值都必须是原子值, 即仅仅是一个简单值而不含内部结构.`**
* **第二范式**
  * **`满足第一范式条件, 而且每个非关键字属性都由整个关键字决定 (而不是由关键字的一部分来决定;`**
* **第三范式**
  * **`符合第二范式的条件,  每个非关键字属性都仅由关键字决定, 而且一个非关键字属性不能仅仅是对另一个非关键字属性的进一步描述 ( 即一个非关键字属性值不能依赖于另一个非关键字属性值).`**











